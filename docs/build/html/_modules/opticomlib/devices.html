<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>opticomlib.devices &mdash; opticomlib 0.4 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/fonts.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=7f00635f"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            opticomlib
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">OptiComLib Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Data types (<code class="xref py py-mod docutils literal notranslate"><span class="pre">opticomlib.typing</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html#models-for-opto-electronic-devices-opticomlib-devices">Models for Opto-Electronic devices (<code class="xref py py-mod docutils literal notranslate"><span class="pre">opticomlib.devices</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html#laboratory-and-practical-functions-opticomlib-lab">Laboratory and practical functions (<code class="xref py py-mod docutils literal notranslate"><span class="pre">opticomlib.lab</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html#ook-devices-opticomlib-ook">OOK devices (<code class="xref py py-mod docutils literal notranslate"><span class="pre">opticomlib.ook</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html#ppm-devices-opticomlib-ppm">PPM devices (<code class="xref py py-mod docutils literal notranslate"><span class="pre">opticomlib.ppm</span></code>)</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">opticomlib</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">opticomlib.devices</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for opticomlib.devices</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">==============================================================</span>
<span class="sd">Models for Opto-Electronic devices (:mod:`opticomlib.devices`)</span>
<span class="sd">==============================================================</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :toctree: generated/</span>

<span class="sd">   PRBS                  -- Pseudorandom binary sequence generator</span>
<span class="sd">   DAC                   -- Digital-to-analog converter (DAC) model</span>
<span class="sd">   PM                    -- Optical phase modulator (PM) model</span>
<span class="sd">   MZM                   -- Mach-Zehnder modulator (MZM) model</span>
<span class="sd">   BPF                   -- Optical band-pass filter (BPF) bessel model</span>
<span class="sd">   EDFA                  -- Erbium-doped fiber amplifier (EDFA) simple model</span>
<span class="sd">   DM                    -- Dispersion medium model</span>
<span class="sd">   FIBER                 -- Optical fiber model (dispersion, attenuation and non-linearities, Split-Step Fourier Method)</span>
<span class="sd">   LPF                   -- Electrical low-pass filter (LPF) bessel model</span>
<span class="sd">   PD                    -- Photodetector (PD) model</span>
<span class="sd">   ADC                   -- Analog-to-digital converter (ADC) model</span>
<span class="sd">   GET_EYE               -- Eye diagram parameters and metrics estimator</span>
<span class="sd">   SAMPLER               -- Sampler device</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="sd">&quot;&quot;&quot;Basic physical models for optical/electronic components.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">sg</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ndarray</span>
<span class="kn">from</span> <span class="nn">scipy.constants</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">k</span> <span class="k">as</span> <span class="n">kB</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">h</span>
<span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">ifft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">sklearn.cluster</span> <span class="k">as</span> <span class="nn">sk</span>
<span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span> <span class="c1"># barra de progreso</span>

<span class="kn">from</span> <span class="nn">.typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">electrical_signal</span><span class="p">,</span>
    <span class="n">binary_sequence</span><span class="p">,</span>
    <span class="n">optical_signal</span><span class="p">,</span>
    <span class="n">gv</span><span class="p">,</span>
    <span class="n">eye</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">generate_prbs</span><span class="p">,</span>
    <span class="n">idbm</span><span class="p">,</span>
    <span class="n">idb</span><span class="p">,</span>
    <span class="n">tic</span><span class="p">,</span>
    <span class="n">toc</span><span class="p">,</span>
<span class="p">)</span>



<div class="viewcode-block" id="PRBS">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.PRBS">[docs]</a>
<span class="k">def</span> <span class="nf">PRBS</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">8</span><span class="p">,</span> 
         <span class="n">user</span><span class="o">=</span><span class="p">[],</span> 
         <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudorandom binary sequence generator.</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int) : lenght of random binary sequence (default: `n=2**8`)</span>
<span class="sd">        user (str | list | ndarray) : binary sequence user pattern (default: `user=[]`)</span>
<span class="sd">        order (int, optional) : degree of the generating pseudorandom polynomial (default: `order=None`)</span>

<span class="sd">    Returns:</span>
<span class="sd">        binary_sequence: generated binary sequence</span>

<span class="sd">    Examples:</span>
<span class="sd">        Using parameter **n**, this function generate a random sequence of lenght `n`. Internally it use ``numpy.random.randint`` function.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; PRBS(10).data</span>
<span class="sd">        array([0, 0, 1, 0, 1, 1, 0, 0, 0, 1], dtype=uint8)</span>

<span class="sd">        On the other hand, the **user** parameter can be used for a custom sequence.</span>
<span class="sd">        We can input it in *str* format separating the values by spaces ``&#39; &#39;`` or by commas ``&#39;,&#39;``. </span>

<span class="sd">        &gt;&gt;&gt; PRBS(user=&#39;1 0 1 0   0 1 1 1   0,1,0,0   1,1,0,1&#39;).data</span>
<span class="sd">        array([1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1], dtype=uint8)</span>

<span class="sd">        The last way in which the function can be used is by passing the **order** of the generating polynomial</span>
<span class="sd">        as an argument, which will return a pseudo-random binary sequence of lenght 2^order-1, using an internal algorithm.</span>

<span class="sd">        &gt;&gt;&gt; PRBS(order=7).data </span>
<span class="sd">        array([1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1,</span>
<span class="sd">            0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1,</span>
<span class="sd">            0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0,</span>
<span class="sd">            0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1,</span>
<span class="sd">            0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0,</span>
<span class="sd">            0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1], dtype=uint8)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">user</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">binary_sequence</span><span class="p">(</span> <span class="n">user</span> <span class="p">)</span>
    <span class="k">elif</span> <span class="n">order</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">binary_sequence</span><span class="p">(</span> <span class="n">generate_prbs</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">binary_sequence</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="DAC">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.DAC">[docs]</a>
<span class="k">def</span> <span class="nf">DAC</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">binary_sequence</span><span class="p">],</span> 
        <span class="n">Vout</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pulse_shape</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;rect&#39;</span><span class="p">,</span><span class="s1">&#39;gaussian&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;rect&#39;</span><span class="p">,</span> 
        <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>  
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Digital-to-Analog Converter. Converts a binary sequence into an electrical signal, sampled at a frequency ``fs``.</span>

<span class="sd">    Args:</span>
<span class="sd">        input (str | list | tuple | ndarray | binary_sequence): Input binary sequence.</span>
<span class="sd">        Vout (float, Optional): Output signal amplitude [-15 to 15 Volts]. (default: `Vout=1.0`)</span>
<span class="sd">        pulse_shape (str, Optional): Pulse shape at the output, can be &quot;rect&quot; or &quot;gaussian&quot;. (default: `pulse_shape=&quot;rect&quot;`)</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">        c (float): Chirp of the Gaussian pulse. Only if `pulse_shape=gaussian`. (default: `c=0.0`)</span>
<span class="sd">        m (int): Order of the super-Gaussian pulse. Only if `pulse_shape=gaussian`. (default: `m=1`)</span>
<span class="sd">        T (int): Pulse width at half maximum in number of samples. Only if `pulse_shape=gaussian`. (default: `T=sps`)</span>

<span class="sd">    Returns:</span>
<span class="sd">        electrical_signal: The converted electrical signal.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `input` type is not in [str, list, tuple, ndarray, binary_sequence].</span>
<span class="sd">        NameError: If `pulse_shape` is not &quot;rect&quot; or &quot;gaussian&quot;.</span>
<span class="sd">        ValueError: If `Vout` is not between -15 and 15 Volts.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; from opticomlib.typing import gv</span>
<span class="sd">        &gt;&gt;&gt; from opticomlib.devices import DAC</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; gv(sps=8) # set samples per bit</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; el_sig = DAC(&#39;0 0 1 0 0&#39;, Vout=5, pulse_shape=&#39;gaussian&#39;, m=2).print().plot(&#39;r.-&#39;).grid()</span>
<span class="sd">        signal : [-1.23381818e-16-2.22738516e-16j  6.16909091e-17-1.05272464e-16j</span>
<span class="sd">        3.77856818e-16+3.15867786e-16j  1.30129261e-16-1.11127678e-16j</span>
<span class="sd">        -3.13522659e-16-1.41649623e-16j -8.08177643e-17+1.58454134e-16j</span>
<span class="sd">        -5.97961758e-17-2.14742015e-16j -3.46122447e-16-5.92476154e-16j</span>
<span class="sd">        -2.38883560e-16-1.06387143e-16j  1.25299722e-16+1.21935938e-16j</span>
<span class="sd">        3.33675895e-11-2.89289740e-17j  2.68302800e-07-7.08598803e-18j</span>
<span class="sd">        1.49408434e-04-5.72763272e-18j  1.04942785e-02+9.24140715e-17j</span>
<span class="sd">        1.60416483e-01+2.67463542e-16j  8.58893815e-01+1.89368799e-16j</span>
<span class="sd">        2.28523831e+00+4.84925496e-16j  3.79394843e+00+4.10134298e-16j</span>
<span class="sd">        4.67939835e+00+4.35662674e-16j  4.96186576e+00+2.07554360e-16j</span>
<span class="sd">        5.00000000e+00+0.00000000e+00j  4.96186576e+00+5.89390367e-16j</span>
<span class="sd">        4.67939835e+00+1.13658240e-16j  3.79394843e+00+4.06283585e-16j</span>
<span class="sd">        2.28523831e+00+1.97133487e-16j  8.58893815e-01+2.02443479e-16j</span>
<span class="sd">        1.60416483e-01+1.40898933e-16j  1.04942785e-02+1.93072645e-16j</span>
<span class="sd">        1.49408434e-04+9.28272207e-17j  2.68302799e-07-2.09299736e-16j</span>
<span class="sd">        3.33672991e-11+8.00938377e-17j  3.95243922e-16+2.04687306e-16j</span>
<span class="sd">        1.44481597e-16+1.47792739e-17j -2.48681540e-16+1.21935938e-16j</span>
<span class="sd">        -8.71750414e-17+1.84774604e-16j -1.41348280e-16+2.06617556e-16j</span>
<span class="sd">        -7.73094327e-17-1.12598266e-16j -1.73505682e-17+9.10904830e-17j</span>
<span class="sd">        -9.25363636e-17+3.54082838e-16j  3.08454545e-16+1.87892798e-16j]</span>
<span class="sd">        noise : [0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j</span>
<span class="sd">        0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j</span>
<span class="sd">        0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j</span>
<span class="sd">        0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]</span>
<span class="sd">        len : 40</span>
<span class="sd">        power : 4.0e+00 W (35.99 dBm)</span>
<span class="sd">        size : 1872 bytes</span>
<span class="sd">        time : 0.0</span>
<span class="sd">        &gt;&gt;&gt;plt.show()</span>

<span class="sd">    .. image:: imgs/DAC_example1.png</span>
<span class="sd">        :alt: Descripción de la imagen</span>
<span class="sd">        :align: center</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">binary_sequence</span><span class="p">):</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="n">binary_sequence</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
    
    <span class="n">sps</span> <span class="o">=</span> <span class="n">kargs</span><span class="p">[</span><span class="s1">&#39;sps&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;sps&#39;</span> <span class="ow">in</span> <span class="n">kargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="n">gv</span><span class="o">.</span><span class="n">sps</span>

    <span class="k">if</span> <span class="n">pulse_shape</span> <span class="o">==</span> <span class="s1">&#39;rect&#39;</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sps</span><span class="p">))</span>
    
    <span class="k">elif</span> <span class="n">pulse_shape</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">kargs</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;c&#39;</span> <span class="ow">in</span> <span class="n">kargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="mf">0.0</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">kargs</span><span class="p">[</span><span class="s1">&#39;m&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;m&#39;</span> <span class="ow">in</span> <span class="n">kargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">kargs</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;T&#39;</span> <span class="ow">in</span> <span class="n">kargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="n">sps</span>

        <span class="n">p</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">T</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">))</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">sps</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">sps</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">sps</span><span class="p">)</span> <span class="c1"># vector de tiempo del pulso gaussiano</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">))</span> <span class="c1"># factor de escala entre el ancho de un slot y la desviación estándar del pulso gaussiano</span>
        <span class="n">pulse</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">T</span><span class="o">/</span><span class="n">k</span><span class="p">)</span> <span class="c1"># pulso gaussiano</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span><span class="o">*</span><span class="n">sps</span><span class="p">)</span>
        <span class="n">s</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">sps</span><span class="o">//</span><span class="mi">2</span><span class="p">)::</span><span class="n">sps</span><span class="p">]</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">data</span>
        <span class="n">s</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">sps</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)::</span><span class="n">sps</span><span class="p">]</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">data</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pulse</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;El parámetro `type` debe ser uno de los siguientes valores (&quot;rect&quot;,&quot;gaussian&quot;).&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Vout</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Vout</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">15</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;El parámetro `Vout` debe ser un valor entre -15 y 15 Volts.&#39;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">Vout</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">electrical_signal</span><span class="p">(</span> <span class="n">x</span> <span class="p">)</span>

    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="PM">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.PM">[docs]</a>
<span class="k">def</span> <span class="nf">PM</span><span class="p">(</span><span class="n">op_input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> 
       <span class="n">el_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">],</span> 
       <span class="n">Vpi</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">5.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optical Phase Modulator (PM) model. Modulate de phase of the input optical signal through input electrical signal.</span>

<span class="sd">    Args:</span>
<span class="sd">        op_input (optical_signal): optical signal to be modulated</span>
<span class="sd">        el_input (float | ndarray | electrical_signal): driver voltage. It can be an integer value, in which case the phase modulation is constant, or an electrical signal of the same length as the optical signal.</span>
<span class="sd">        Vpi (float, Optional): voltage at which the device achieves a phase shift of π (default: ``Vpi=5.0`` [V])</span>

<span class="sd">    Returns:</span>
<span class="sd">        optical_signal: modulated optical signal</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If ``op_input`` type is not `optical_signal`.</span>
<span class="sd">        TypeError: If ``el_input`` type is not in [`float`, `ndarray`, `electrical_signal`].</span>
<span class="sd">        ValueError: If ``el_input`` is ndarray or `electrical_signal` but, length is not equal to ``op_input`` length.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; from opticomlib.typing import optical_signal, gv</span>
<span class="sd">        &gt;&gt;&gt; from opticomlib.devices import PM</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; gv(sps=8, R=1e9) # set samples per bit and bitrate</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; op_input = optical_signal(np.exp(1j*np.linspace(0,4*np.pi, 1000))) # input optical signal ( exp(j*w*t) )</span>
<span class="sd">        &gt;&gt;&gt; t = op_input.t()*1e9</span>
<span class="sd">        &gt;&gt;&gt; w = 4*np.pi/t[-1]</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Constant phase</span>
<span class="sd">        &gt;&gt;&gt; output = PM(op_input, el_input=2.5, Vpi=5)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; plt.subplot(311)</span>
<span class="sd">        &gt;&gt;&gt; plt.plot(t, op_input.phase()[0] - w*t, &#39;r&#39;, t, output.phase()[0] - w*t, &#39;b&#39;, lw=3)</span>
<span class="sd">        &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">        &gt;&gt;&gt; plt.ylabel(&#39;Fase [rad]&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.legend([&#39;input&#39;, &#39;output&#39;], bbox_to_anchor=(1, 1), loc=&#39;upper left&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.title(r&#39;Constant phase change ($\Delta f=0$)&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Lineal phase</span>
<span class="sd">        &gt;&gt;&gt; output = PM(op_input, el_input=np.linspace(0,5*np.pi,op_input.len()), Vpi=5)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; plt.subplot(312)</span>
<span class="sd">        &gt;&gt;&gt; plt.plot(t, op_input.phase()[0] - w*t, &#39;r-&#39;, t, output.phase()[0] - w*t, &#39;b&#39;, lw=3)</span>
<span class="sd">        &gt;&gt;&gt; plt.xticks([])</span>
<span class="sd">        &gt;&gt;&gt; plt.ylabel(&#39;Fase [rad]&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.title(r&#39;Linear phase change  ($\Delta f \\rightarrow cte.$)&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Quadratic phase</span>
<span class="sd">        &gt;&gt;&gt; output = PM(op_input, el_input=np.linspace(0,(5*np.pi)**0.5,op_input.len())**2, Vpi=5)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; plt.subplot(313)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; plt.plot(t, op_input.phase()[0] - w*t, &#39;r-&#39;, t, output.phase()[0] - w*t, &#39;b&#39;, lw=3)</span>
<span class="sd">        &gt;&gt;&gt; plt.xlabel(&#39;Tiempo [ns]&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.ylabel(&#39;Fase [rad]&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.title(r&#39;Quadratic phase change ($\Delta f \\rightarrow linear$)&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.tight_layout()</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>

<span class="sd">    .. image:: imgs/PM_example1.png</span>
<span class="sd">        :alt: result of PM example 1</span>
<span class="sd">        :align: center</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op_input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`op_input` must be of type (optical_signal).&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el_input</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="n">el_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op_input</span><span class="o">.</span><span class="n">len</span><span class="p">())</span> <span class="o">*</span> <span class="n">el_input</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el_input</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">):</span>
        <span class="n">el_input</span> <span class="o">=</span> <span class="n">el_input</span><span class="o">.</span><span class="n">signal</span>
        <span class="k">if</span> <span class="n">el_input</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">op_input</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">len</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The length of `el_input` must be equal to the length of `op_input`.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el_input</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">el_input</span><span class="p">)</span> <span class="o">!=</span> <span class="n">op_input</span><span class="o">.</span><span class="n">len</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The length of `el_input` must be equal to the length of `op_input`.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`el_input` must be of type (int or electrical_signal).&quot;</span><span class="p">)</span>
    
    <span class="n">output</span> <span class="o">=</span> <span class="n">optical_signal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">op_input</span><span class="o">.</span><span class="n">signal</span><span class="p">))</span>

    <span class="n">output</span><span class="o">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">op_input</span><span class="o">.</span><span class="n">signal</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">el_input</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="n">Vpi</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">op_input</span><span class="o">.</span><span class="n">noise</span><span class="p">):</span>
        <span class="n">output</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">op_input</span><span class="o">.</span><span class="n">noise</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">el_input</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="n">Vpi</span><span class="p">)</span>
    
    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="MZM">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.MZM">[docs]</a>
<span class="k">def</span> <span class="nf">MZM</span><span class="p">(</span><span class="n">op_input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> 
        <span class="n">el_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">],</span> 
        <span class="n">bias</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> 
        <span class="n">Vpi</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> 
        <span class="n">loss_dB</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> 
        <span class="n">eta</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> 
        <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">40e9</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mach-Zehnder modulator (MZM) model. Asymmetric coupler and opposite driving voltages (V1=-V2 Push-Pull config). </span>
<span class="sd">    </span>
<span class="sd">    See model theory in `Tetsuya Kawanishi - Electro-optic Modulation for Photonic Networks (Textbooks in Telecommunication Engineering)-Springer (2022)` Chapter 4.3.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        op_input (optical_signal): Optical signal to be modulated.</span>
<span class="sd">        el_input (float | ndarray | electrical_signal): Driver voltage.</span>
<span class="sd">        bias (float, Optional): Modulator bias voltage (default: 0.0 [V]).</span>
<span class="sd">        Vpi (float, Optional): Voltage at which the device switches from on-state to off-state (default: 5.0 [V]).</span>
<span class="sd">        loss_dB (float, Optional): Propagation or insertion losses in the modulator, value in dB (default: 0.0).</span>
<span class="sd">        eta (float, Optional): Imbalance ratio of light intensity between the two arms of the modulator (default: 0.1). ER = -20*log10(eta/2) (=26 dB by default).</span>
<span class="sd">        BW (float, Optional): Modulator bandwidth in [Hz] (default: 40e9).</span>

<span class="sd">    Returns:</span>
<span class="sd">        optical_signal: Modulated optical signal.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If ``op_input`` type is not `optical_signal`.</span>
<span class="sd">        TypeError: If ``el_input`` type is not in [`float`, `ndarray`, `electrical_signal`].</span>
<span class="sd">        ValueError: If ``el_input`` is ndarray or `electrical_signal` but, length is not equal to ``op_input`` length.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tic</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op_input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span> 
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`op_input` debe ser del tipo (optical_signal).&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el_input</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="n">el_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op_input</span><span class="o">.</span><span class="n">len</span><span class="p">())</span> <span class="o">*</span> <span class="n">el_input</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el_input</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">):</span>
        <span class="n">el_input</span> <span class="o">=</span> <span class="n">el_input</span><span class="o">.</span><span class="n">signal</span>
        <span class="k">if</span> <span class="n">el_input</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">op_input</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">len</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;La longitud de `el_input` debe ser igual a la longitud de `op_input`.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el_input</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">el_input</span><span class="p">)</span> <span class="o">!=</span> <span class="n">op_input</span><span class="o">.</span><span class="n">len</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;La longitud de `el_input` debe ser igual a la longitud de `op_input`.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`el_input` debe ser del tipo (int, float, ndarray ó electrical_signal).&quot;</span><span class="p">)</span>
    
    <span class="n">loss</span> <span class="o">=</span> <span class="n">idb</span><span class="p">(</span><span class="o">-</span><span class="n">loss_dB</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">op_input</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">g_t</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">Vpi</span> <span class="o">*</span> <span class="p">(</span><span class="n">el_input</span> <span class="o">+</span> <span class="n">bias</span><span class="p">)</span>
    <span class="n">output</span><span class="o">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">op_input</span><span class="o">.</span><span class="n">signal</span> <span class="o">*</span> <span class="n">loss</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">g_t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">eta</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">g_t</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">op_input</span><span class="o">.</span><span class="n">noise</span><span class="p">):</span>
        <span class="n">output</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">op_input</span><span class="o">.</span><span class="n">noise</span> <span class="o">*</span> <span class="n">loss</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">g_t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">eta</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">g_t</span><span class="p">))</span>

    <span class="n">t_</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">LPF</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">BW</span><span class="p">)</span>

    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">+=</span> <span class="n">t_</span> 
    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="BPF">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.BPF">[docs]</a>
<span class="k">def</span> <span class="nf">BPF</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> 
        <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> 
        <span class="n">fs</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optical Band-Pass Filter (BPF). Filters the input optical signal, allowing only the desired frequency band to pass.</span>
<span class="sd">    Bessel filter model.</span>

<span class="sd">    Args:</span>
<span class="sd">        input (optical_signal): The optical signal to be filtered.</span>
<span class="sd">        BW (float): The bandwidth of the filter in Hz.</span>
<span class="sd">        n (int, Optional): The order of the filter (default: ``n=4``).</span>
<span class="sd">        fs (float, Optional): The sampling frequency of the input signal (default: ``fs=gv.fs``).</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        optical_signal: The filtered optical signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`input` must be of type (optical_signal).&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">fs</span><span class="p">:</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">fs</span>

    <span class="n">sos_band</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">bessel</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">Wn</span><span class="o">=</span><span class="n">BW</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;sos&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">optical_signal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">())))</span>

    <span class="n">output</span><span class="o">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos_band</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">):</span>
        <span class="n">output</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos_band</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="EDFA">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.EDFA">[docs]</a>
<span class="k">def</span> <span class="nf">EDFA</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> 
         <span class="n">G</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
         <span class="n">NF</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
         <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Erbium Doped Fiber (EDFA). Amplifies the optical signal at the input, adding amplified spontaneous emission (ASE) noise. </span>
<span class="sd">    Simplest model (no saturation output power).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        input (optical_signal): The optical signal to be amplified.</span>
<span class="sd">        G (float): The gain of the amplifier, in [dB].</span>
<span class="sd">        NF (float): The noise figure of the amplifier, in [dB].</span>
<span class="sd">        BW (float): The bandwidth of the amplifier, in [Hz].</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        optical_signal: The amplified optical signal.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: if ``input`` is not an optical signal.    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`input` must be of type (optical_signal).&quot;</span><span class="p">)</span>
     
    <span class="n">output</span> <span class="o">=</span> <span class="n">BPF</span><span class="p">(</span> <span class="nb">input</span> <span class="o">*</span> <span class="n">idb</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">BW</span> <span class="p">)</span>
    <span class="c1"># ase = BPF( optical_signal( np.zeros_like(input.signal), np.exp(-1j*np.random.uniform(0, 2*pi, input.noise.shape)) ), BW )</span>
    <span class="n">ase</span> <span class="o">=</span> <span class="n">BPF</span><span class="p">(</span> <span class="n">optical_signal</span><span class="p">(</span> <span class="n">noise</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span> <span class="p">),</span> <span class="n">BW</span> <span class="p">)</span>
    <span class="n">t_</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">+</span> <span class="n">ase</span><span class="o">.</span><span class="n">ejecution_time</span>
    
    <span class="n">tic</span><span class="p">()</span>
    <span class="n">P_ase</span> <span class="o">=</span> <span class="n">idb</span><span class="p">(</span><span class="n">NF</span><span class="p">)</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="n">gv</span><span class="o">.</span><span class="n">f0</span> <span class="o">*</span> <span class="p">(</span><span class="n">idb</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">BW</span>

    <span class="n">norm_x</span><span class="p">,</span> <span class="n">norm_y</span> <span class="o">=</span> <span class="n">ase</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="s1">&#39;noise&#39;</span><span class="p">)</span> <span class="c1"># power of ASE noise in [W] for each polarization</span>

    <span class="n">ase</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">norm_x</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">/</span> <span class="p">(</span><span class="n">P_ase</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">ase</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">norm_y</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">/</span> <span class="p">(</span><span class="n">P_ase</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>

    <span class="n">output</span> <span class="o">+=</span> <span class="n">ase</span>

    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">t_</span> <span class="o">+</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="DM">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.DM">[docs]</a>
<span class="k">def</span> <span class="nf">DM</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> <span class="n">D</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dispersive Medium. Emulates a medium with only the dispersion property, i.e., only `beta_2` different from zero.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        input (optical_signal): The input optical signal.</span>
<span class="sd">        D (float): The dispersion coefficient of the medium (β2·z), in [ps^2].</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        optical_signal: The output optical signal.</span>
<span class="sd">    </span>
<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If ``input`` is not an optical signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The input must be an optical signal!&quot;</span><span class="p">)</span> 

    <span class="c1"># Convert units of D:</span>
    <span class="n">D</span> <span class="o">*=</span> <span class="mf">1e-12</span><span class="o">**</span><span class="mi">2</span>
    
    <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="nb">input</span><span class="o">.</span><span class="n">w</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="o">/</span><span class="mi">2</span> <span class="p">))(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
    
    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="FIBER">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.FIBER">[docs]</a>
<span class="k">def</span> <span class="nf">FIBER</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> 
          <span class="n">length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
          <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> 
          <span class="n">beta_2</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> 
          <span class="n">beta_3</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> 
          <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> 
          <span class="n">phi_max</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> 
          <span class="n">show_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Optical Fiber.</span>

<span class="sd">    Simulates the transmission through an optical fiber, solving Schrödinger&#39;s equation numerically,</span>
<span class="sd">    by using split-step Fourier method with adaptative step (method based on limmiting the nonlilear phase rotation). </span>
<span class="sd">    Polarization mode dispersion (PMD) is not considered in this model.</span>

<span class="sd">    paper source: https://ieeexplore.ieee.org/document/1190149</span>

<span class="sd">    Args:</span>
<span class="sd">        input (optical_signal): Input optical signal.</span>
<span class="sd">        length (float): Length of the fiber, in [km].</span>
<span class="sd">        alpha (float, Optional): Attenuation coefficient of the fiber, in [dB/km] (default: 0.0).</span>
<span class="sd">        beta_2 (float, Optional): Second-order dispersion coefficient of the fiber, in [ps^2/km] (default: 0.0).</span>
<span class="sd">        beta_3 (float, Optional): Third-order dispersion coefficient of the fiber, in [ps^3/km] (default: 0.0).</span>
<span class="sd">        gamma (float, Optional): Nonlinearity coefficient of the fiber, in [(W·km)^-1] (default: 0.0).</span>
<span class="sd">        phi_max (float, Optional): Upper bound of the nonlinear phase rotation, in [rad] (default: 0.05).</span>
<span class="sd">        show_progress (bool, Optional): Show progress bar (default: False).</span>

<span class="sd">    Returns:</span>
<span class="sd">        optical_signal: Output optical signal.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If ``input`` is not an optical signal.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; from opticomlib.typing import optical_signal, gv</span>
<span class="sd">        &gt;&gt;&gt; from opticomlib.devices import FIBER, DAC</span>
<span class="sd">        &gt;&gt;&gt; from opticomlib.utils import idbm</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; gv(sps=32, R=10e9)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; signal = DAC(&#39;0,0,0,1,0,0,0&#39;, pulse_shape=&#39;gaussian&#39;)</span>
<span class="sd">        &gt;&gt;&gt; input = optical_signal( signal.signal/signal.power()**0.5*idbm(20) )</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; output = FIBER(input, length=50, alpha=0.01, beta_2=-20, gamma=2, show_progress=True)</span>
<span class="sd">        100%|█████████████████████████████████████████████| 100.0/100 [00:00&lt;00:00, 12591.73it/s]</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; input.plot(&#39;r-&#39;, label=&#39;input&#39;, lw=3)</span>
<span class="sd">        &gt;&gt;&gt; output.plot(&#39;b-&#39;, label=&#39;output&#39;, lw=3).grid()</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>

<span class="sd">    .. image:: imgs/FIBER_example1.png</span>
<span class="sd">        :alt: result of FIBER example 1</span>
<span class="sd">        :align: center</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tic</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`input` must be of type (optical_signal).&quot;</span><span class="p">)</span>

    <span class="n">alpha</span>  <span class="o">=</span> <span class="n">alpha</span><span class="o">/</span><span class="mf">4.343</span> <span class="c1"># [1/km]</span>

    <span class="n">w</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">w</span><span class="p">()</span><span class="o">*</span><span class="mf">1e-12</span> <span class="c1"># [rad/ps]</span>
    <span class="n">D_op</span> <span class="o">=</span> <span class="o">-</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">beta_2</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">6</span> <span class="o">*</span> <span class="n">beta_3</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">3</span>

    <span class="n">A</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="k">if</span> <span class="p">(</span><span class="n">beta_2</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">beta_3</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">gamma</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="n">phi_max</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="n">x_length</span> <span class="o">=</span> <span class="n">h</span>

    <span class="k">if</span> <span class="n">show_progress</span><span class="p">:</span>
        <span class="n">barra_progreso</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">exp_NL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D_op</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span> <span class="n">exp_L</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span> <span class="c1"># Symmetric Split-Step Fourier Method </span>

        <span class="k">if</span> <span class="n">show_progress</span><span class="p">:</span>
            <span class="n">barra_progreso</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">h</span> <span class="o">/</span> <span class="n">length</span> <span class="p">)</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">phi_max</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">if</span> <span class="n">gamma</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">length</span> 

        <span class="k">if</span> <span class="n">x_length</span> <span class="o">+</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">x_length</span> <span class="o">+=</span> <span class="n">h</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">x_length</span>
    
    <span class="k">if</span> <span class="n">h</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">exp_NL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D_op</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span> <span class="n">exp_L</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">show_progress</span><span class="p">:</span>
            <span class="n">barra_progreso</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">h</span> <span class="o">/</span> <span class="n">length</span> <span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">optical_signal</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">noise</span> <span class="p">)</span>
    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="LPF">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.LPF">[docs]</a>
<span class="k">def</span> <span class="nf">LPF</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">],</span> 
        <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> 
        <span class="n">fs</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Low Pass Filter (LPF) for electrical signals. Filters the input electrical signal, allowing only the desired frequency band to pass.</span>
<span class="sd">    Bessel filter model.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        input (ndarray | electrical_signal): Electrical signal to be filtered.</span>
<span class="sd">        BW (float): Filter bandwidth or cutoff frecuency, in [Hz].</span>
<span class="sd">        n (int, optional): Filter order (default: 4).</span>
<span class="sd">        fs (float, optional): Sampling frequency of the input signal (default: ``fs=gv.fs``).</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        electrical_signal: Filtered electrical signal.</span>
<span class="sd">    </span>
<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If ``input`` is not of type ndarray or electrical_signal.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; from opticomlib.typing import electrical_signal, gv</span>
<span class="sd">        &gt;&gt;&gt; from opticomlib.devices import LPF</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; gv(N = 10, sps=128, R=1e9)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; t = gv.t</span>
<span class="sd">        &gt;&gt;&gt; c = 20e9/t[-1]   # frequency chirp from 0 to 20 GHz</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; input = electrical_signal( np.sin( np.pi*c*t**2) )</span>
<span class="sd">        &gt;&gt;&gt; output = LPF(input, 10e9)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; input.psd(&#39;r&#39;, label=&#39;input&#39;, lw=2)</span>
<span class="sd">        &gt;&gt;&gt; output.psd(&#39;b&#39;, label=&#39;output&#39;, lw=2).show()</span>
<span class="sd">    </span>
<span class="sd">    .. image:: imgs/LPF_example1.png</span>
<span class="sd">        :alt: result of LPF example 1</span>
<span class="sd">        :align: center</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="p">(</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`input` must be of type (ndarray or electrical_signal).&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">):</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span>
            <span class="n">noise</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">noise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="nb">input</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">fs</span><span class="p">:</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">fs</span>

    <span class="n">sos_band</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">bessel</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="n">n</span><span class="p">,</span> <span class="n">Wn</span> <span class="o">=</span> <span class="n">BW</span><span class="p">,</span> <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;sos&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">electrical_signal</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">output</span><span class="o">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos_band</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">noise</span><span class="p">):</span>
        <span class="n">output</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos_band</span><span class="p">,</span> <span class="n">noise</span><span class="p">)</span>
    
    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="PD">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.PD">[docs]</a>
<span class="k">def</span> <span class="nf">PD</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> 
       <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
       <span class="n">responsivity</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> 
       <span class="n">T</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">300.0</span><span class="p">,</span> 
       <span class="n">R_load</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">50.0</span><span class="p">,</span> 
       <span class="n">noise</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;ase-only&#39;</span><span class="p">,</span><span class="s1">&#39;thermal-only&#39;</span><span class="p">,</span><span class="s1">&#39;shot-only&#39;</span><span class="p">,</span><span class="s1">&#39;ase-thermal&#39;</span><span class="p">,</span><span class="s1">&#39;ase-shot&#39;</span><span class="p">,</span><span class="s1">&#39;thermal-shot&#39;</span><span class="p">,</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Photodetector. </span>
<span class="sd">    </span>
<span class="sd">    Simulates the detection of an optical signal by a photodetector.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        input (optical_signal): optical signal to be detected</span>
<span class="sd">        BW (float): detector bandwidth in [Hz]</span>
<span class="sd">        responsivity (float, Optional): detector responsivity in [A/W] (default: 1.0)</span>
<span class="sd">        T (float, Optional): detector temperature in [K] (default: 300.0)</span>
<span class="sd">        R_load (float, Optional): detector load resistance in [Ohm] (default: 50.0)</span>
<span class="sd">        noise (str, Optional): type of noise to include in the simulation (default: &#39;all&#39;)</span>
<span class="sd">            </span>
<span class="sd">            - ``&#39;ase-only&#39;``: only include ASE noise</span>
<span class="sd">            - ``&#39;thermal-only&#39;``: only include thermal noise</span>
<span class="sd">            - ``&#39;shot-only&#39;``: only include shot noise</span>
<span class="sd">            - ``&#39;ase-thermal&#39;``: include ASE and thermal noise</span>
<span class="sd">            - ``&#39;ase-shot&#39;``: include ASE and shot noise</span>
<span class="sd">            - ``&#39;thermal-shot&#39;``: include thermal and shot noise</span>
<span class="sd">            - ``&#39;all&#39;``: include all types of noise</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        electrical_signal: the detected electrical signal</span>
<span class="sd">    </span>
<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if the ``noise`` argument is not one of the valid options</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="n">i_sig</span> <span class="o">=</span> <span class="n">responsivity</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="s1">&#39;signal&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># se suman las dos polarizaciones</span>

    <span class="k">if</span> <span class="s1">&#39;thermal&#39;</span> <span class="ow">in</span> <span class="n">noise</span> <span class="ow">or</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="n">noise</span><span class="p">:</span>
        <span class="n">S_T</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">kB</span> <span class="o">*</span> <span class="n">T</span> <span class="o">*</span> <span class="n">BW</span> <span class="o">/</span> <span class="n">R_load</span> <span class="c1"># Density of thermal noise in [A^2]</span>
        <span class="n">i_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">S_T</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">())</span>
    
    <span class="k">if</span> <span class="s1">&#39;shot&#39;</span> <span class="ow">in</span> <span class="n">noise</span> <span class="ow">or</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="n">noise</span><span class="p">:</span>
        <span class="n">S_N</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">e</span> <span class="o">*</span> <span class="n">i_sig</span> <span class="o">*</span> <span class="n">BW</span> <span class="c1"># Density of shot noise in [A^2]</span>
        <span class="n">i_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="p">))(</span><span class="n">S_N</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;ase&#39;</span> <span class="ow">in</span> <span class="n">noise</span> <span class="ow">or</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="n">noise</span><span class="p">:</span>
        <span class="n">i_sig_sp</span> <span class="o">=</span> <span class="n">responsivity</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">+</span> \
                            <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                            <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">+</span> \
                            <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">i_sp_sp</span> <span class="o">=</span> <span class="n">responsivity</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="s1">&#39;noise&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># se suman las dos polarizaciones</span>

    <span class="k">if</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;ase-only&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_sig_sp</span>  <span class="o">+</span> <span class="n">i_sp_sp</span>
    <span class="k">elif</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;thermal-only&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_T</span> 
    <span class="k">elif</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;shot-only&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_N</span>
    <span class="k">elif</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;ase-shot&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_sig_sp</span>  <span class="o">+</span> <span class="n">i_sp_sp</span> <span class="o">+</span> <span class="n">i_N</span> 
    <span class="k">elif</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;ase-thermal&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_sig_sp</span>  <span class="o">+</span> <span class="n">i_sp_sp</span> <span class="o">+</span> <span class="n">i_T</span> 
    <span class="k">elif</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;thermal-shot&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_T</span> <span class="o">+</span> <span class="n">i_N</span> 
    <span class="k">elif</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_sig_sp</span>  <span class="o">+</span> <span class="n">i_sp_sp</span> <span class="o">+</span> <span class="n">i_N</span> <span class="o">+</span> <span class="n">i_T</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The argument `noise` must be one of the following: &#39;ase-only&#39;,&#39;thermal-only&#39;,&#39;shot-only&#39;,&#39;ase-thermal&#39;,&#39;ase-shot&#39;,&#39;thermal-shot&#39;,&#39;all&#39;.&quot;</span><span class="p">)</span>
    
    <span class="n">t_</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="n">filt</span> <span class="o">=</span> <span class="n">LPF</span><span class="p">(</span><span class="n">i_sig</span><span class="p">,</span> <span class="n">BW</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">electrical_signal</span><span class="p">(</span><span class="n">filt</span><span class="o">.</span><span class="n">signal</span><span class="p">,</span> <span class="n">noise</span><span class="p">)</span>

    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">filt</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">+</span> <span class="n">t_</span>
    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="ADC">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.ADC">[docs]</a>
<span class="k">def</span> <span class="nf">ADC</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">electrical_signal</span><span class="p">,</span> <span class="n">fs</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nbits</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">binary_sequence</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Analog-to-Digital Converter. </span>
<span class="sd">    </span>
<span class="sd">    Converts an analog electrical signal into a quantized digital signal, sampled at a frequency `fs`</span>
<span class="sd">    and filtered with a bandwidth BW.</span>

<span class="sd">    Args:</span>
<span class="sd">        input (electrical_signal): Electrical signal to be quantized.</span>
<span class="sd">        fs (float, Optional): Sampling frequency of the output signal. (default: None).</span>
<span class="sd">        BW (float, Optional): ADC bandwidth in Hz. (default: None).</span>
<span class="sd">        nbits (int, Optional): Vertical resolution of the ADC, in bits. (default: 8 bits).</span>

<span class="sd">    Returns:</span>
<span class="sd">        electrical_signal: Quantized digital signal.</span>

<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the ``input`` is not of type `electrical_signal`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`input` debe ser del tipo (electrical_signal).&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">fs</span><span class="p">:</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">fs</span>

    <span class="k">if</span> <span class="n">BW</span><span class="p">:</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">bessel</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">Wn</span> <span class="o">=</span> <span class="n">BW</span><span class="p">,</span> <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">fs</span><span class="p">(),</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;sos&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span><span class="p">)</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">signal</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span>

    <span class="n">signal</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span><span class="o">*</span><span class="n">fs</span><span class="o">/</span><span class="nb">input</span><span class="o">.</span><span class="n">fs</span><span class="p">()))</span>

    <span class="n">V_min</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">V_max</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">dig_signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span> <span class="p">(</span><span class="n">signal</span> <span class="o">-</span> <span class="n">V_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">V_max</span> <span class="o">-</span> <span class="n">V_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="c1"># normalizo la señal entre 0 y 2**nbits-1</span>
    <span class="n">dig_signal</span> <span class="o">=</span> <span class="n">dig_signal</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">V_max</span> <span class="o">-</span> <span class="n">V_min</span><span class="p">)</span> <span class="o">+</span> <span class="n">V_min</span> <span class="c1"># vuelvo a la amplitud original</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">):</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">)</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span><span class="o">*</span><span class="n">fs</span><span class="o">//</span><span class="nb">input</span><span class="o">.</span><span class="n">fs</span><span class="p">()))</span>
        <span class="n">V_min</span> <span class="o">=</span> <span class="n">noise</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">V_max</span> <span class="o">=</span> <span class="n">noise</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">dig_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span> <span class="p">(</span><span class="n">noise</span> <span class="o">-</span> <span class="n">V_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">V_max</span> <span class="o">-</span> <span class="n">V_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="c1"># normalizo la señal entre 0 y 2**nbits-1</span>
        <span class="n">dig_noise</span> <span class="o">=</span> <span class="n">dig_noise</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">V_max</span> <span class="o">-</span> <span class="n">V_min</span><span class="p">)</span> <span class="o">+</span> <span class="n">V_min</span> <span class="c1"># vuelvo a la amplitud original</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">electrical_signal</span><span class="p">(</span> <span class="n">dig_signal</span><span class="p">,</span> <span class="n">dig_noise</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">electrical_signal</span><span class="p">(</span> <span class="n">dig_signal</span> <span class="p">)</span>

    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="GET_EYE">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.GET_EYE">[docs]</a>
<span class="k">def</span> <span class="nf">GET_EYE</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">electrical_signal</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">],</span> <span class="n">nslots</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span> <span class="n">sps_resamp</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get Eye Params.</span>
<span class="sd">    </span>
<span class="sd">    Estimates all the fundamental parameters and metrics of the eye diagram of the input electrical signal.</span>

<span class="sd">    Args:</span>
<span class="sd">        input (electrical_signal | optical_signal): Electrical or optical signal from which the eye diagram will be estimated.</span>
<span class="sd">        nslots (int, Optional): Number of slots to consider for eye reconstruction (default: 4096).</span>
<span class="sd">        sps_resamp (int, Optional): Number of samples per slot to interpolate de original signal (default: None).</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        eye: Object of the Eye class with all the parameters and metrics of the eye diagram.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; from opticomlib.typing import gv</span>
<span class="sd">        &gt;&gt;&gt; from opticomlib.devices import PRBS, DAC, GET_EYE</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; gv(N = 10, sps=64, R=1e9)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; y = DAC( PRBS(), pulse_shape=&#39;gaussian&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y.noise = np.random.normal(0, 0.05, y.len())</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; GET_EYE(y, sps_resamp=512).plot() # without interpolation</span>

<span class="sd">    .. image:: imgs/GET_EYE_example1.png</span>
<span class="sd">        :alt: result of GET_EYE example 1</span>
<span class="sd">        :align: center</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">shorth_int</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimation of the shortest interval containing 50% of the samples in &#39;data&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): Array of data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[float, float]: The shortest interval containing 50% of the samples in &#39;data&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">diff_lag</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">data</span><span class="p">,</span><span class="n">lag</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="n">lag</span><span class="p">:]</span><span class="o">-</span><span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="n">lag</span><span class="p">]</span>  <span class="c1"># Difference between two elements of an array separated by a distance &#39;lag&#39;</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">lag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">diff_lag</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">lag</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span><span class="o">&lt;</span><span class="mf">1e-10</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">lag</span><span class="p">])</span>
    
    <span class="k">def</span> <span class="nf">find_nearest</span><span class="p">(</span><span class="n">levels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the element in &#39;levels&#39; that is closest to each value in &#39;data&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            levels (np.ndarray): Reference levels.</span>
<span class="sd">            data (Union[np.ndarray, float]): Values to compare.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Union[np.ndarray, float]: Vector or float with the values from &#39;levels&#39; corresponding to each value in &#39;data&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">levels</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">levels</span> <span class="o">-</span> <span class="n">data</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">levels</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">levels</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">,(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)]</span>

    <span class="n">eye_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">sps</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">sps</span><span class="p">();</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;sps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sps</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">dt</span><span class="p">();</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt</span>

    
    <span class="n">n</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">sps</span><span class="p">:]</span><span class="o">.</span><span class="n">len</span><span class="p">()</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">sps</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">n</span><span class="p">:</span> <span class="nb">input</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">sps</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">]</span>
    
    <span class="n">nslots</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span><span class="o">//</span><span class="n">sps</span><span class="o">//</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">nslots</span><span class="p">)</span>
    <span class="nb">input</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[:</span><span class="n">nslots</span><span class="o">*</span><span class="n">sps</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">):</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="o">+</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The argument &#39;input&#39; must be &#39;optical_signal&#39; o &#39;electrical_signal&#39;.&quot;</span><span class="p">)</span>

    <span class="nb">input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="o">-</span><span class="n">sps</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># To focus the eye on the chart</span>
    <span class="n">y_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>

    <span class="c1"># resampled the signal to obtain a higher resolution in both axes</span>
    <span class="k">if</span> <span class="n">sps_resamp</span><span class="p">:</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">nslots</span><span class="o">*</span><span class="n">sps_resamp</span><span class="p">);</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nslots</span><span class="o">//</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">dt</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">sps_resamp</span><span class="p">));</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span><span class="o">//</span><span class="n">sps</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">dt</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">sps</span><span class="p">));</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>

    <span class="c1"># We obtain the centroid of the samples on the Y axis</span>
    <span class="n">vm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">)</span>

    <span class="c1"># we obtain the shortest interval of the upper half that contains 50% of the samples</span>
    <span class="n">top_int</span> <span class="o">=</span> <span class="n">shorth_int</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="nb">input</span><span class="o">&gt;</span><span class="n">vm</span><span class="p">])</span> 
    <span class="c1"># We obtain the LMS of level 1</span>
    <span class="n">state_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">top_int</span><span class="p">)</span>
    <span class="c1"># we obtain the shortest interval of the lower half that contains 50% of the samples</span>
    <span class="n">bot_int</span> <span class="o">=</span> <span class="n">shorth_int</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="nb">input</span><span class="o">&lt;</span><span class="n">vm</span><span class="p">])</span>
    <span class="c1"># We obtain the LMS of level 0</span>
    <span class="n">state_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bot_int</span><span class="p">)</span>

    <span class="c1"># We obtain the amplitude between the two levels 0 and 1</span>
    <span class="n">d01</span> <span class="o">=</span> <span class="n">state_1</span> <span class="o">-</span> <span class="n">state_0</span>

    <span class="c1"># We take 75% threshold level</span>
    <span class="n">v75</span> <span class="o">=</span> <span class="n">state_1</span> <span class="o">-</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">d01</span>

    <span class="c1"># We take 25% threshold level</span>
    <span class="n">v25</span> <span class="o">=</span> <span class="n">state_0</span> <span class="o">+</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">d01</span>

    <span class="n">t_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>

    <span class="c1"># The following vector will be used only to determine the crossing times</span>
    <span class="n">tt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[(</span><span class="nb">input</span><span class="o">&gt;</span><span class="n">v25</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="nb">input</span><span class="o">&lt;</span><span class="n">v75</span><span class="p">)]</span>

    <span class="c1"># We get the centroid of the time data</span>
    <span class="n">tm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">)</span>

    <span class="c1"># We obtain the left crossing time</span>
    <span class="n">t_left</span> <span class="o">=</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">t_set</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tt</span><span class="p">[</span><span class="n">tt</span><span class="o">&lt;</span><span class="n">tm</span><span class="p">]));</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_left&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_left</span>

    <span class="c1"># We obtain the crossing time from the right</span>
    <span class="n">t_right</span> <span class="o">=</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">t_set</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tt</span><span class="p">[</span><span class="n">tt</span><span class="o">&gt;</span><span class="n">tm</span><span class="p">]));</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_right</span>

    <span class="c1"># Determine the center of the eye</span>
    <span class="n">t_center</span> <span class="o">=</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">t_set</span><span class="p">,</span> <span class="p">(</span><span class="n">t_left</span> <span class="o">+</span> <span class="n">t_right</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_opt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_center</span>

    <span class="c1"># For 20% of the center of the eye diagram</span>
    <span class="n">t_dist</span> <span class="o">=</span> <span class="n">t_right</span> <span class="o">-</span> <span class="n">t_left</span><span class="p">;</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_dist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_dist</span>
    <span class="n">t_span0</span> <span class="o">=</span> <span class="n">t_center</span> <span class="o">-</span> <span class="mf">0.05</span><span class="o">*</span><span class="n">t_dist</span><span class="p">;</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_span0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_span0</span>
    <span class="n">t_span1</span> <span class="o">=</span> <span class="n">t_center</span> <span class="o">+</span> <span class="mf">0.05</span><span class="o">*</span><span class="n">t_dist</span><span class="p">;</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_span1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_span1</span>

    <span class="c1"># Within the 20% of the data in the center of the eye diagram, we separate into two clusters top and bottom</span>
    <span class="n">y_center</span> <span class="o">=</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">y_set</span><span class="p">,</span> <span class="p">(</span><span class="n">state_0</span> <span class="o">+</span> <span class="n">state_1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># We obtain the optimum time for down sampling</span>
    <span class="k">if</span> <span class="n">sps_resamp</span><span class="p">:</span>
        <span class="n">instant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t_center</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span> <span class="o">-</span> <span class="n">sps_resamp</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">instant</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">instant</span><span class="o">/</span><span class="n">sps_resamp</span><span class="o">*</span><span class="n">sps</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">instant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t_center</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span> <span class="o">-</span> <span class="n">sps</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">instant</span>

    <span class="c1"># We obtain the upper cluster</span>
    <span class="n">y_top</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[(</span><span class="nb">input</span> <span class="o">&gt;</span> <span class="n">y_center</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">t_span0</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_span1</span><span class="p">))];</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;y_top&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_top</span>

    <span class="c1"># We obtain the lower cluster</span>
    <span class="n">y_bot</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[(</span><span class="nb">input</span> <span class="o">&lt;</span> <span class="n">y_center</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">t_span0</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_span1</span><span class="p">))];</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;y_bot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_bot</span>

    <span class="c1"># For each cluster we calculated the means and standard deviations</span>
    <span class="n">mu1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_top</span><span class="p">);</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;mu1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu1</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">y_top</span><span class="p">);</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;s1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s1</span>
    <span class="n">mu0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_bot</span><span class="p">);</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;mu0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu0</span>
    <span class="n">s0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">y_bot</span><span class="p">);</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;s0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s0</span>

    <span class="c1"># We obtain the extinction ratio</span>
    <span class="n">er</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">mu1</span><span class="o">/</span><span class="n">mu0</span><span class="p">)</span> <span class="k">if</span> <span class="n">mu0</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">;</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;er&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">er</span>

    <span class="c1"># We obtain the eye opening</span>
    <span class="n">eye_h</span> <span class="o">=</span> <span class="n">mu1</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">s1</span> <span class="o">-</span> <span class="n">mu0</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">s0</span><span class="p">;</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;eye_h&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eye_h</span>

    <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;ejecution_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">eye</span><span class="p">(</span><span class="n">eye_dict</span><span class="p">)</span></div>



<div class="viewcode-block" id="SAMPLER">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.SAMPLER">[docs]</a>
<span class="k">def</span> <span class="nf">SAMPLER</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">electrical_signal</span><span class="p">,</span> <span class="n">_eye_</span><span class="p">:</span> <span class="n">eye</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Receives an electrical signal and an eye object and performs the sampling of the signal</span>
<span class="sd">    at the optimal instant determined by the eye object.</span>

<span class="sd">    Args:</span>
<span class="sd">        input: The electrical signal to be sampled.</span>
<span class="sd">        _eye_: The eye object that contains the eye diagram information.</span>

<span class="sd">    Returns:</span>
<span class="sd">        electrical_signal: The sampled electrical signal at one sample per slot.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>
    <span class="n">output</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">_eye_</span><span class="o">.</span><span class="n">i</span><span class="p">::</span><span class="n">_eye_</span><span class="o">.</span><span class="n">sps</span><span class="p">]</span>

    <span class="n">output</span><span class="o">.</span><span class="n">execution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>







<span class="c1">### algunas funciones de prueba</span>
<span class="k">def</span> <span class="nf">animated_fiber_propagation</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> <span class="n">M</span> <span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">length_</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">alpha_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">beta_2_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">beta_3_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">gamma_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">phi_max</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">matplotlib.animation</span> <span class="kn">import</span> <span class="n">FuncAnimation</span>

    <span class="c1"># cambio las unidades</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">length_</span> <span class="o">*</span> <span class="mf">1e3</span> 
    <span class="n">alpha</span>  <span class="o">=</span> <span class="n">alpha_</span> <span class="o">*</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mf">4.343</span><span class="o">*</span><span class="mf">1e3</span><span class="p">)</span>
    <span class="n">beta_2</span> <span class="o">=</span> <span class="n">beta_2_</span> <span class="o">*</span> <span class="mf">1e-12</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">1e3</span>
    <span class="n">beta_3</span> <span class="o">=</span> <span class="n">beta_3_</span> <span class="o">*</span> <span class="mf">1e-12</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mf">1e3</span>
    <span class="n">gamma</span>  <span class="o">=</span> <span class="n">gamma_</span> <span class="o">*</span> <span class="mi">1</span><span class="o">/</span><span class="mf">1e3</span>

    <span class="n">w</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">w</span><span class="p">()</span>
    <span class="n">D_op</span> <span class="o">=</span> <span class="o">-</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">beta_2</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">6</span> <span class="o">*</span> <span class="n">beta_3</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">3</span>

    <span class="n">A</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="k">if</span> <span class="p">(</span><span class="n">beta_2</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">beta_3</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">gamma</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="n">phi_max</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="n">x_length</span> <span class="o">=</span> <span class="n">h</span>
    <span class="n">A_z</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">]</span>
    <span class="n">hs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">exp_NL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D_op</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span> <span class="n">exp_L</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">A_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">hs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">phi_max</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">if</span> <span class="n">gamma</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">length</span> 

        <span class="k">if</span> <span class="n">x_length</span> <span class="o">+</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">x_length</span> <span class="o">+=</span> <span class="n">h</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">x_length</span>
    
    <span class="k">if</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">exp_NL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D_op</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span> <span class="n">exp_L</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">A_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">hs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">t</span><span class="p">()</span><span class="o">*</span><span class="n">gv</span><span class="o">.</span><span class="n">slot_rate</span>

    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

    <span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
    <span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Fiber: $\alpha = </span><span class="si">{:.2f}</span><span class="s1">$ dB/km, $\beta_2 = </span><span class="si">{}</span><span class="s1">$ ps^2/km, $\gamma = </span><span class="si">{}</span><span class="s1">$ (W·km)^-1&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">alpha_</span><span class="p">,</span> <span class="n">beta_2_</span><span class="p">,</span> <span class="n">gamma_</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$t/T_</span><span class="si">{slot}</span><span class="s1">$&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;|A(z,t)|&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">*</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1.05</span><span class="p">))</span>

    <span class="n">time_text</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span><span class="mf">0.9</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
        <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">([],[])</span>
        <span class="n">time_text</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s1">&#39;z = 0.0 Km&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[::</span><span class="n">M</span><span class="o">*</span><span class="n">gv</span><span class="o">.</span><span class="n">sps</span><span class="p">]:</span>
           <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[::</span><span class="n">gv</span><span class="o">.</span><span class="n">sps</span><span class="p">]:</span>
           <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">line</span><span class="p">,</span> <span class="n">time_text</span><span class="p">]</span> 

    <span class="k">def</span> <span class="nf">animate</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">time_text</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s1">&#39;z = </span><span class="si">{:.2f}</span><span class="s1"> Km&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">hs</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mf">1e3</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">line</span><span class="p">,</span> <span class="n">time_text</span><span class="p">]</span> 

    <span class="n">anim</span> <span class="o">=</span> <span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">animate</span><span class="p">,</span> <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">A_z</span><span class="p">),</span> <span class="n">interval</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">animated_fiber_propagation_with_psd</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> <span class="n">M</span> <span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">length_</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">alpha_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">beta_2_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">beta_3_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">gamma_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">phi_max</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">matplotlib.animation</span> <span class="kn">import</span> <span class="n">FuncAnimation</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">n</span><span class="o">*</span><span class="n">M</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">sps</span><span class="p">()</span> 
    
    <span class="n">length</span> <span class="o">=</span> <span class="n">length_</span>
    <span class="n">alpha</span>  <span class="o">=</span> <span class="n">alpha_</span><span class="o">/</span><span class="mf">4.343</span>
    <span class="n">beta_2</span> <span class="o">=</span> <span class="n">beta_2_</span>
    <span class="n">beta_3</span> <span class="o">=</span> <span class="n">beta_3_</span>
    <span class="n">gamma</span>  <span class="o">=</span> <span class="n">gamma_</span>

    <span class="n">w</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">w</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e-12</span> <span class="c1"># rad/ps</span>
    <span class="n">D_op</span> <span class="o">=</span> <span class="o">-</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">beta_2</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">6</span> <span class="o">*</span> <span class="n">beta_3</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">3</span>

    <span class="n">A</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="k">if</span> <span class="p">(</span><span class="n">beta_2</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">beta_3</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">gamma</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="n">phi_max</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="n">x_length</span> <span class="o">=</span> <span class="n">h</span>
    <span class="n">A_z</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">]</span>
    <span class="n">A_z_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">fft</span><span class="p">(</span><span class="n">A</span><span class="p">)]</span>
    <span class="n">hs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">exp_NL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D_op</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span> <span class="n">exp_L</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">A_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">x_length</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">A_z_w</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fft</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">x_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">hs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">phi_max</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">if</span> <span class="n">gamma</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">length</span> 

        <span class="k">if</span> <span class="n">x_length</span> <span class="o">+</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">x_length</span> <span class="o">+=</span> <span class="n">h</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">x_length</span>
    
    <span class="k">if</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">exp_NL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D_op</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span> <span class="n">exp_L</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">A_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">length</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">A_z_w</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fft</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">length</span><span class="o">/</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">hs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">t</span><span class="p">()</span><span class="o">*</span><span class="n">gv</span><span class="o">.</span><span class="n">slot_rate</span>

    <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span><span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>

    <span class="n">line1</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">[</span><span class="mi">0</span><span class="p">])[:</span><span class="n">n</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
    <span class="n">line1</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Fiber: $\alpha = </span><span class="si">{:.2f}</span><span class="s1">$ dB/km, $\beta_2 = </span><span class="si">{}</span><span class="s1">$ ps^2/km, $\gamma = </span><span class="si">{}</span><span class="s1">$ (W·km)^-1&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">alpha_</span><span class="p">,</span> <span class="n">beta_2_</span><span class="p">,</span> <span class="n">gamma_</span><span class="p">))</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;t/T&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;|A(z,t)|&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">[:</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>

    <span class="n">z_text</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span><span class="mf">0.9</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="mf">1e3</span> <span class="c1"># GHz</span>

    <span class="n">line2</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z_w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">(),</span> <span class="s1">&#39;--g&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">line2</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;f [GHz]&#39;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$|A(z,w)|^2$&#39;</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="o">-</span><span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A_z_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.001</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z_w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="p">))</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z_w</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="mf">1.05</span><span class="o">/</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()))</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
        <span class="n">line1</span><span class="o">.</span><span class="n">set_data</span><span class="p">([],[])</span>
        <span class="n">z_text</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s1">&#39;z = 0.0 Km&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[:</span><span class="n">n</span><span class="p">:</span><span class="n">M</span><span class="o">*</span><span class="n">gv</span><span class="o">.</span><span class="n">sps</span><span class="p">]:</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[:</span><span class="n">n</span><span class="p">:</span><span class="n">gv</span><span class="o">.</span><span class="n">sps</span><span class="p">]:</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">line1</span><span class="p">,</span> <span class="n">z_text</span><span class="p">]</span> 

    <span class="k">def</span> <span class="nf">animate</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">line1</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">y</span><span class="p">[:</span><span class="n">n</span><span class="p">])</span>
        <span class="n">z_text</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s1">&#39;z = </span><span class="si">{:.2f}</span><span class="s1"> Km&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">hs</span><span class="p">)[</span><span class="n">i</span><span class="p">]))</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z_w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span>
        <span class="n">line2</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">line1</span><span class="p">,</span> <span class="n">line2</span><span class="p">,</span> <span class="n">z_text</span><span class="p">]</span> 

    <span class="n">anim</span> <span class="o">=</span> <span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">animate</span><span class="p">,</span> <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">A_z</span><span class="p">),</span> <span class="n">interval</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># def Spectrogram(signal, T_L):</span>
    <span class="c1">#     N = signal.len()//T_L</span>
    <span class="c1">#     y = np.zeros(N*T_L)</span>
    <span class="c1">#     for i in range(N):</span>
    <span class="c1">#         y[i*T_L:(i+1)*T_L] = fftshift(np.abs( fft(signal.signal[i*T_L:(i+1)*T_L]) )**2)</span>
    <span class="c1">#     y = y.reshape((N, T_L)).T</span>
    <span class="c1">#     return y</span>


    <span class="c1"># sps = 2048</span>
    <span class="c1"># gv(M=8, sps=sps, R=10e9)</span>
    <span class="c1"># y = DAC(&#39;0 1 0 1 0 0 1&#39;, pulse_shape=&#39;gaussian&#39;, T=sps, m=1, c=-50)</span>
    <span class="c1"># N_TL = 128</span>
    <span class="c1"># # g = Spectrogram(y, N_TL)</span>
    <span class="c1"># # f = y.w()/(2*np.pi)</span>
    <span class="c1"># # plt.imshow(g, cmap=&#39;hot&#39;, aspect=&#39;auto&#39;, interpolation=&#39;blackman&#39;, extent=[y.t().min()*1e9, y.t().max()*1e9, f.min()*1e-9, f.max()*1e-9])</span>
    <span class="c1"># # plt.ylim(-1000,1000)</span>
    <span class="c1"># # y.plot(ylabel=&#39;Voltaje (V)&#39;,c=&#39;red&#39;).grid()</span>
    <span class="c1"># plt.figure()</span>
    <span class="c1"># plt.plot(y.t(), y.abs(&#39;signal&#39;))</span>
    <span class="c1"># # for i in range(y.len()//N_TL):</span>
    <span class="c1"># #     plt.axvline(y.t()[i*N_TL], ls=&#39;--&#39;)</span>
    <span class="c1"># plt.show()</span>
    <span class="k">pass</span>



</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Ing. Armando P. Romeu.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>