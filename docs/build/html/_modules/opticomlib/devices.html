<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>opticomlib.devices &mdash; opticomlib 0.4 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/fonts.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=7f00635f"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            opticomlib
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">OptiComLib Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Data types (<code class="xref py py-mod docutils literal notranslate"><span class="pre">opticomlib.typing</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html#models-for-opto-electronic-devices-opticomlib-devices">Models for Opto-Electronic devices (<code class="xref py py-mod docutils literal notranslate"><span class="pre">opticomlib.devices</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html#laboratory-and-practical-functions-opticomlib-lab">Laboratory and practical functions (<code class="xref py py-mod docutils literal notranslate"><span class="pre">opticomlib.lab</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html#ook-devices-opticomlib-ook">OOK devices (<code class="xref py py-mod docutils literal notranslate"><span class="pre">opticomlib.ook</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html#ppm-devices-opticomlib-ppm">PPM devices (<code class="xref py py-mod docutils literal notranslate"><span class="pre">opticomlib.ppm</span></code>)</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">opticomlib</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">opticomlib.devices</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for opticomlib.devices</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">==============================================================</span>
<span class="sd">Models for Opto-Electronic devices (:mod:`opticomlib.devices`)</span>
<span class="sd">==============================================================</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :toctree: generated/</span>

<span class="sd">   PRBS                  -- Pseudorandom binary sequence generator</span>
<span class="sd">   DAC                   -- Digital-to-analog converter (DAC) model</span>
<span class="sd">   PM                    -- Optical phase modulator (PM) model</span>
<span class="sd">   MZM                   -- Mach-Zehnder modulator (MZM) model</span>
<span class="sd">   BPF                   -- Optical band-pass filter (BPF) bessel model</span>
<span class="sd">   EDFA                  -- Erbium-doped fiber amplifier (EDFA) simple model</span>
<span class="sd">   DM                    -- Dispersion medium model</span>
<span class="sd">   FIBER                 -- Optical fiber model (dispersion, attenuation and non-linearities, Split-Step Fourier Method)</span>
<span class="sd">   LPF                   -- Electrical low-pass filter (LPF) bessel model</span>
<span class="sd">   PD                    -- Photodetector (PD) model</span>
<span class="sd">   ADC                   -- Analog-to-digital converter (ADC) model</span>
<span class="sd">   GET_EYE               -- Eye diagram parameters and metrics estimator</span>
<span class="sd">   SAMPLER               -- Sampler device</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="sd">&quot;&quot;&quot;Basic physical models for optical/electronic components.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">sg</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ndarray</span>
<span class="kn">from</span> <span class="nn">scipy.constants</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">k</span> <span class="k">as</span> <span class="n">kB</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">h</span>
<span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">ifft</span><span class="p">,</span> <span class="n">fftshift</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">sklearn.cluster</span> <span class="k">as</span> <span class="nn">sk</span>
<span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span> <span class="c1"># barra de progreso</span>

<span class="kn">from</span> <span class="nn">.typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">electrical_signal</span><span class="p">,</span>
    <span class="n">binary_sequence</span><span class="p">,</span>
    <span class="n">optical_signal</span><span class="p">,</span>
    <span class="n">global_vars</span><span class="p">,</span>
    <span class="n">eye</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">generate_prbs</span><span class="p">,</span>
    <span class="n">idbm</span><span class="p">,</span>
    <span class="n">idb</span><span class="p">,</span>
    <span class="n">tic</span><span class="p">,</span>
    <span class="n">toc</span><span class="p">,</span>
<span class="p">)</span>



<div class="viewcode-block" id="PRBS">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.PRBS">[docs]</a>
<span class="k">def</span> <span class="nf">PRBS</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">8</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="p">[],</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pseudorandom binary sequence generator.</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int) : lenght of random binary sequence (default: `n=2**8`)</span>
<span class="sd">        user (str | list | ndarray) : binary sequence user pattern (default: `user=[]`)</span>
<span class="sd">        order (int) : degree of the generating pseudorandom polynomial (default: `order=None`)</span>

<span class="sd">    Returns:</span>
<span class="sd">        binary_sequence: generated binary sequence</span>

<span class="sd">    Examples:</span>
<span class="sd">        Using parameter **n**, this function generate a random sequence of lenght `n`. Internally it use ``numpy.random.randint`` function.</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; PRBS(10).data</span>
<span class="sd">        array([0, 0, 1, 0, 1, 1, 0, 0, 0, 1], dtype=uint8)</span>

<span class="sd">        On the other hand, the **user** parameter can be used for a custom sequence.</span>
<span class="sd">        We can input it in *str* format separating the values by spaces ``&#39; &#39;`` or by commas ``&#39;,&#39;``. </span>

<span class="sd">        &gt;&gt;&gt; PRBS(user=&#39;1 0 1 0   0 1 1 1   0,1,0,0   1,1,0,1&#39;).data</span>
<span class="sd">        array([1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1], dtype=uint8)</span>

<span class="sd">        The last way in which the function can be used is by passing the **order** of the generating polynomial</span>
<span class="sd">        as an argument, which will return a pseudo-random binary sequence of lenght 2*order-1, using an internal algorithm.</span>

<span class="sd">        &gt;&gt;&gt; PRBS(order=7).data </span>
<span class="sd">        array([1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1,</span>
<span class="sd">            0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1,</span>
<span class="sd">            0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0,</span>
<span class="sd">            0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1,</span>
<span class="sd">            0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0,</span>
<span class="sd">            0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1], dtype=uint8)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">user</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">binary_sequence</span><span class="p">(</span> <span class="n">user</span> <span class="p">)</span>
    <span class="k">elif</span> <span class="n">order</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">binary_sequence</span><span class="p">(</span> <span class="n">generate_prbs</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">binary_sequence</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="DAC">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.DAC">[docs]</a>
<span class="k">def</span> <span class="nf">DAC</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">binary_sequence</span><span class="p">],</span> 
        <span class="n">Vout</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pulse_shape</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;rect&#39;</span><span class="p">,</span><span class="s1">&#39;gaussian&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;rect&#39;</span><span class="p">,</span> 
        <span class="o">**</span><span class="n">kargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">electrical_signal</span><span class="p">:</span>  
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Conversor digital a analógico. Convierte una secuencia binaria en una señal eléctrica, muestreada a una frecuencia `fs`.</span>

<span class="sd">    ---</span>

<span class="sd">    ### Args:</span>
<span class="sd">    - `input` - secuencia binaria de entrada</span>
<span class="sd">    - `Vout` [Opcional] - amplitud de la señal de salida [-15 a 15 Voltios] (default: `amplitud=5.0`)</span>
<span class="sd">    - `pulse_shape` [Opcional] - forma de pulso a la salida, puede ser &quot;rect&quot; o &quot;gaussian&quot; (default: `type=&quot;rect&quot;`)</span>

<span class="sd">    ---</span>
<span class="sd">    </span>
<span class="sd">    ### Kargs:</span>
<span class="sd">    - `c` [Opcional] - chirp del pulso gaussiano. Solo si `type=gaussian` (default: `c=0.0`)</span>
<span class="sd">    - `m` [Opcional] - orden del pulso supergausiano. Solo si `type=gaussian` (default: `m=1`)</span>
<span class="sd">    - `T` [Opcional] - ancho a mitad de altura del pulso gaussiano en cantidad de muestras. Solo si `type=gaussian` (default: `T=sps`)</span>
<span class="sd">    ---</span>

<span class="sd">    ### Returns:</span>
<span class="sd">    - `electrical_signal`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">binary_sequence</span><span class="p">):</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="n">binary_sequence</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
    
    <span class="n">sps</span> <span class="o">=</span> <span class="n">kargs</span><span class="p">[</span><span class="s1">&#39;sps&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;sps&#39;</span> <span class="ow">in</span> <span class="n">kargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="n">global_vars</span><span class="o">.</span><span class="n">sps</span>

    <span class="k">if</span> <span class="n">pulse_shape</span> <span class="o">==</span> <span class="s1">&#39;rect&#39;</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sps</span><span class="p">))</span>
    
    <span class="k">elif</span> <span class="n">pulse_shape</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">kargs</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;c&#39;</span> <span class="ow">in</span> <span class="n">kargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="mf">0.0</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">kargs</span><span class="p">[</span><span class="s1">&#39;m&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;m&#39;</span> <span class="ow">in</span> <span class="n">kargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">kargs</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;T&#39;</span> <span class="ow">in</span> <span class="n">kargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="n">sps</span>

        <span class="n">p</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">T</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">))</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">sps</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">sps</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">sps</span><span class="p">)</span> <span class="c1"># vector de tiempo del pulso gaussiano</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">))</span> <span class="c1"># factor de escala entre el ancho de un slot y la desviación estándar del pulso gaussiano</span>
        <span class="n">pulse</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">T</span><span class="o">/</span><span class="n">k</span><span class="p">)</span> <span class="c1"># pulso gaussiano</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span><span class="o">*</span><span class="n">sps</span><span class="p">)</span>
        <span class="n">s</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">sps</span><span class="o">//</span><span class="mi">2</span><span class="p">)::</span><span class="n">sps</span><span class="p">]</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">data</span>
        <span class="n">s</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">sps</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)::</span><span class="n">sps</span><span class="p">]</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">data</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pulse</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;El parámetro `type` debe ser uno de los siguientes valores (&quot;rect&quot;,&quot;gaussian&quot;).&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Vout</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">Vout</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">electrical_signal</span><span class="p">(</span> <span class="n">x</span> <span class="p">)</span>

    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="PM">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.PM">[docs]</a>
<span class="k">def</span> <span class="nf">PM</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">],</span> <span class="n">Vpi</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span><span class="o">-&gt;</span> <span class="n">optical_signal</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modula en fase la señal óptica de entrada, a partir de una señal eléctrica de entrada.</span>
<span class="sd">    </span>
<span class="sd">    ---</span>

<span class="sd">    ### Args:</span>
<span class="sd">    - `input` - señal óptica a modular</span>
<span class="sd">    - `v` - voltaje del driver. Puede ser valor entero en cuyo caso la modulación de fase es constante, o una señal eléctrica de la misma longitud que la señal óptica.</span>
<span class="sd">    - `Vpi` [Opcional] - voltaje para el cual el dispositivo logra un desfasaje de π (default: `Vpi=5.0` [V])</span>

<span class="sd">    ---</span>

<span class="sd">    ### Returns:</span>
<span class="sd">    - `optical_signal`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`input` debe ser del tipo (optical_signal).&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">())</span> <span class="o">*</span> <span class="n">v</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">signal</span>
        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">len</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;La longitud de `v` debe ser igual a la longitud de `input`.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;La longitud de `v` debe ser igual a la longitud de `input`.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`v` debe ser del tipo (int ó electrical_signal).&quot;</span><span class="p">)</span>
    
    <span class="n">output</span> <span class="o">=</span> <span class="n">optical_signal</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">output</span><span class="o">.</span><span class="n">signal</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="n">Vpi</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">):</span>
        <span class="n">output</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">noise</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="n">Vpi</span><span class="p">)</span>
    
    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="MZM">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.MZM">[docs]</a>
<span class="k">def</span> <span class="nf">MZM</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">],</span> <span class="n">bias</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">Vpi</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">loss_dB</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">eta</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">40e9</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">optical_signal</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mach-Zehnder modulator (MZM) model. Asymmetric coupler and opposite driving voltages (V1=-V2 Push-Pull config). </span>
<span class="sd">    </span>
<span class="sd">    See model theory in `Tetsuya Kawanishi - Electro-optic Modulation for Photonic Networks (Textbooks in Telecommunication Engineering)-Springer (2022)` Chapter 4.3.</span>
<span class="sd">    </span>
<span class="sd">    ---</span>

<span class="sd">    ### Args:</span>
<span class="sd">    - `input` - señal óptica a modular</span>
<span class="sd">    - `V` - voltaje del driver. </span>
<span class="sd">    - `bias` [Opcional] - voltaje de polarización del modulador (default: `bias=0.0` [V])</span>
<span class="sd">    - `Vpi` [Opcional] - voltaje para el cual el dispositivo pasa de on-state a off-state (default: `Vpi=5.0` [V])</span>
<span class="sd">    - `loss_dB` [Opcional] - pérdidas de propagación o insersión en el modulador, valor en dB (default: `loss_dB=0.0`)</span>
<span class="sd">    - `eta` [Opcional] - relación de imbalancede la intensidad de la luz entre los dos brazos del modulador (default: `eta=0.1`). ER = -20*log10(eta/2) = 26 dB</span>
<span class="sd">    - `BW` [Opcional] - ancho de banda del modulador en [Hz] (default: `BW=10e9`)</span>

<span class="sd">    ---</span>

<span class="sd">    ### Returns:</span>
<span class="sd">    - `optical_signal`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span> 
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`input` debe ser del tipo (optical_signal).&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">())</span> <span class="o">*</span> <span class="n">V</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">):</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">signal</span>
        <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">len</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;La longitud de `V` debe ser igual a la longitud de `input`.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;La longitud de `V` debe ser igual a la longitud de `input`.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`V` debe ser del tipo (int, float, ndarray ó electrical_signal).&quot;</span><span class="p">)</span>
    
    <span class="n">loss</span> <span class="o">=</span> <span class="n">idb</span><span class="p">(</span><span class="o">-</span><span class="n">loss_dB</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">g_t</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">Vpi</span> <span class="o">*</span> <span class="p">(</span><span class="n">V</span> <span class="o">+</span> <span class="n">bias</span><span class="p">)</span>
    <span class="n">output</span><span class="o">.</span><span class="n">signal</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span> <span class="o">*</span> <span class="n">loss</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">g_t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">eta</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">g_t</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">):</span>
        <span class="n">output</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">noise</span> <span class="o">*</span> <span class="n">loss</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">g_t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">eta</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">g_t</span><span class="p">))</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">LPF</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">BW</span><span class="p">)</span>

    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="MODULATOR">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.MODULATOR">[docs]</a>
<span class="k">def</span> <span class="nf">MODULATOR</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">electrical_signal</span><span class="p">,</span> <span class="n">p_laser</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pol</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">optical_signal</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modula la señal óptica de un láser de potencia dada,79 a partir de una señal eléctrica de entrada.</span>
<span class="sd">    </span>
<span class="sd">    ---</span>

<span class="sd">    ### Args:</span>
<span class="sd">    - `input` - señal eléctrica moduladora</span>
<span class="sd">    - `p_laser` [Opcional] - potencia del laser en [dBm] (default: `p_laser=global_vars.p_laser`)</span>
<span class="sd">    - `pol` [Opcional] - eje de polarización de la señal óptica de salida (default: `x`)</span>
<span class="sd">    </span>
<span class="sd">    ---</span>

<span class="sd">    ### Returns:</span>
<span class="sd">    - `optical_signal`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>
    
    <span class="n">i</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`input` debe ser del tipo (electrical_signal).&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`pol` debe ser (&#39;x&#39; o &#39;y&#39;).&quot;</span><span class="p">)</span>
    
    <span class="n">p_laser</span> <span class="o">=</span> <span class="n">idbm</span><span class="p">(</span><span class="n">p_laser</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">optical_signal</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()))</span> <span class="p">)</span>

    <span class="n">opt_signal</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="o">/</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="s1">&#39;signal&#39;</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_laser</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">output</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="n">pol</span><span class="p">]]</span> <span class="o">=</span> <span class="n">opt_signal</span>
    
    <span class="k">if</span> <span class="nb">input</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="s1">&#39;noise&#39;</span><span class="p">):</span>
        <span class="n">opt_noise</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="o">/</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="s1">&#39;noise&#39;</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_laser</span><span class="o">**</span><span class="mf">0.5</span>
        <span class="n">output</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="n">pol</span><span class="p">]]</span> <span class="o">=</span> <span class="n">opt_noise</span>
    
    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="BPF">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.BPF">[docs]</a>
<span class="k">def</span> <span class="nf">BPF</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">fs</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">optical_signal</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filtro Pasa Banda (BPF) Óptico. Filtra la señal óptica de entrada, dejando pasar la banda de frecuencias deseada. </span>
<span class="sd">    </span>
<span class="sd">    ---</span>

<span class="sd">    ### Args:</span>
<span class="sd">    - `input` - señal óptica a filtrar</span>
<span class="sd">    - `BW` - ancho de banda del filtro en [Hz]</span>
<span class="sd">    - `n` [Opcional] - orden del filtro (default: `n=4`)</span>
<span class="sd">    - `fs` [Opcional] - frecuencia de muestreo de la señal de entrada (default: `fs=globals_vars.fs`)</span>
<span class="sd">    </span>
<span class="sd">    ---</span>
<span class="sd">    </span>
<span class="sd">    ### Returns:</span>
<span class="sd">    - `optical_signal`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`input` debe ser del tipo (optical_signal).&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">fs</span><span class="p">:</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">global_vars</span><span class="o">.</span><span class="n">fs</span>

    <span class="n">sos_band</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">bessel</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="n">n</span><span class="p">,</span> <span class="n">Wn</span> <span class="o">=</span> <span class="n">BW</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;sos&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">optical_signal</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()))</span> <span class="p">)</span>

    <span class="n">output</span><span class="o">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos_band</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">):</span>
        <span class="n">output</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos_band</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="EDFA">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.EDFA">[docs]</a>
<span class="k">def</span> <span class="nf">EDFA</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> <span class="n">G</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">NF</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span> <span class="c1"># modelo simplificado del EDFA (no satura)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Amplificador de fibra dopada con Erbium. Amplifica la señal óptica a la entrada, agregando ruido de emisión espontánea amplificada (ASE). </span>
<span class="sd">    </span>
<span class="sd">    ---</span>

<span class="sd">    ### Args: </span>
<span class="sd">    - `input` - señal óptica a amplificar</span>
<span class="sd">    - `G` - ganancia del amplificador en [dB]</span>
<span class="sd">    - `NF` - figura de ruido del amplificador en [dB]</span>
<span class="sd">    - `BW` - ancho de banda del amplificador en [Hz] </span>
<span class="sd">    </span>
<span class="sd">    ---</span>

<span class="sd">    ### Returns:</span>
<span class="sd">    -</span>
<span class="sd">    - `output` (optical_signal) - señal óptica de salida</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`input` debe ser del tipo (optical_signal).&quot;</span><span class="p">)</span>
     
    <span class="n">output</span> <span class="o">=</span> <span class="n">BPF</span><span class="p">(</span> <span class="nb">input</span> <span class="o">*</span> <span class="n">idb</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">BW</span> <span class="p">)</span>
    <span class="n">ase</span> <span class="o">=</span> <span class="n">BPF</span><span class="p">(</span> <span class="n">optical_signal</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span> <span class="p">),</span> <span class="n">BW</span> <span class="p">)</span>
    <span class="n">ejc_time</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">+</span> <span class="n">ase</span><span class="o">.</span><span class="n">ejecution_time</span>
    
    <span class="n">tic</span><span class="p">()</span>
    <span class="n">P_ase</span> <span class="o">=</span> <span class="n">idb</span><span class="p">(</span><span class="n">NF</span><span class="p">)</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="n">global_vars</span><span class="o">.</span><span class="n">f0</span> <span class="o">*</span> <span class="p">(</span><span class="n">idb</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">BW</span>

    <span class="n">norm_x</span><span class="p">,</span> <span class="n">norm_y</span> <span class="o">=</span> <span class="n">ase</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="s1">&#39;noise&#39;</span><span class="p">)</span> <span class="c1"># potencia de ruido de ASE en [W] para cada polarización</span>

    <span class="n">ase</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">norm_x</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">/</span> <span class="p">(</span><span class="n">P_ase</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">ase</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">norm_y</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">/</span> <span class="p">(</span><span class="n">P_ase</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>

    <span class="n">output</span> <span class="o">+=</span> <span class="n">ase</span>

    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">ejc_time</span> <span class="o">+</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="DM">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.DM">[docs]</a>
<span class="k">def</span> <span class="nf">DM</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> <span class="n">beta_2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">length</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">optical_signal</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Medio Dispersivo. Emula un medio con solo la propiedad de dispersión, es decir solo `beta_2` diferente de cero. </span>
<span class="sd">    </span>
<span class="sd">    ---</span>
<span class="sd">    </span>
<span class="sd">    ### Args:</span>
<span class="sd">    - `signal` - señal óptica de entrada</span>
<span class="sd">    - `beta_2` - coeficiente de dispersión de la fibra en [ps^2/km]</span>
<span class="sd">    - `length` - longitud del medio dispersivo en [km]</span>
<span class="sd">    </span>
<span class="sd">    ---</span>
<span class="sd">    </span>
<span class="sd">    ### Returns:</span>
<span class="sd">    - `optical_signal`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;El argumento debe ser una señal óptica!&quot;</span><span class="p">)</span> 

    <span class="c1"># cambio las unidades de beta_2 y length:</span>
    <span class="n">beta_2</span> <span class="o">=</span> <span class="n">beta_2</span> <span class="o">*</span> <span class="mf">1e-12</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">1e3</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">length</span> <span class="o">*</span> <span class="mf">1e3</span> 
    
    <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">beta_2</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">input</span><span class="o">.</span><span class="n">w</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">length</span><span class="p">))(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
    
    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="FIBER">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.FIBER">[docs]</a>
<span class="k">def</span> <span class="nf">FIBER</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> <span class="n">length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">beta_2</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">beta_3</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">phi_max</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">show_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">optical_signal</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fibra Óptica. Simula la transmisión por fibra de una señal óptica de entrada teniendo en cuenta los efectos de la atenuación, dispersión y no linealidades. </span>
<span class="sd">    </span>
<span class="sd">    ---</span>

<span class="sd">    ### Args:</span>
<span class="sd">    - `input` - señal óptica de entrada</span>
<span class="sd">    - `length` - longitud de la fibra en [km]</span>
<span class="sd">    - `alpha` [Opcional] - coeficiente de atenuación de la fibra en [dB/km] (default: `alpha=0.0`)</span>
<span class="sd">    - `beta_2` [Opcional] - coeficiente de dispersión de segundo orden de la fibra en [ps^2/km] (default: `beta_2=0.0`)</span>
<span class="sd">    - `beta_3` [Opcional] - coeficiente de dispersión de tercer orden de la fibra en [ps^3/km] (default: `beta_3=0.0`)</span>
<span class="sd">    - `gamma` [Opcional] - coeficiente de no linealidad de la fibra en [(W·km)^-1] (default: `gamma=0.0`)</span>
<span class="sd">    - `phi_max` [Opcional] - cota superior de la fase no lineal en [rad] (default: `phi_max=0.05`)</span>
<span class="sd">    - `show_progress` [Opcional] - mostrar barra de progreso (default: `show_progress=False`)</span>
<span class="sd">    </span>
<span class="sd">    ---</span>
<span class="sd">    </span>
<span class="sd">    ### Returns:</span>
<span class="sd">    - `optical_signal`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tic</span><span class="p">()</span>
    <span class="n">alpha</span>  <span class="o">=</span> <span class="n">alpha</span><span class="o">/</span><span class="mf">4.343</span> <span class="c1"># [1/km]</span>

    <span class="n">w</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">w</span><span class="p">()</span><span class="o">*</span><span class="mf">1e-12</span> <span class="c1"># [rad/ps]</span>
    <span class="n">D_op</span> <span class="o">=</span> <span class="o">-</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">beta_2</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">6</span> <span class="o">*</span> <span class="n">beta_3</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">3</span>

    <span class="n">A</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="k">if</span> <span class="p">(</span><span class="n">beta_2</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">beta_3</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">gamma</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="n">phi_max</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="n">x_length</span> <span class="o">=</span> <span class="n">h</span>

    <span class="k">if</span> <span class="n">show_progress</span><span class="p">:</span>
        <span class="n">barra_progreso</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">exp_NL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D_op</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span> <span class="n">exp_L</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span>

        <span class="k">if</span> <span class="n">show_progress</span><span class="p">:</span>
            <span class="n">barra_progreso</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">h</span> <span class="o">/</span> <span class="n">length</span> <span class="p">)</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">phi_max</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">if</span> <span class="n">gamma</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">length</span> 

        <span class="k">if</span> <span class="n">x_length</span> <span class="o">+</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">x_length</span> <span class="o">+=</span> <span class="n">h</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">x_length</span>
    
    <span class="k">if</span> <span class="n">h</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">exp_NL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D_op</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span> <span class="n">exp_L</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">show_progress</span><span class="p">:</span>
            <span class="n">barra_progreso</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">h</span> <span class="o">/</span> <span class="n">length</span> <span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">optical_signal</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">noise</span> <span class="p">)</span>
    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="LPF">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.LPF">[docs]</a>
<span class="k">def</span> <span class="nf">LPF</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">],</span> <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">fs</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">electrical_signal</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filtro Pasa Bajo (LPF) Eléctrico. Filtra la señal eléctrica de entrada, dejando pasar la banda de frecuencias deseada. </span>
<span class="sd">        </span>
<span class="sd">        ---</span>

<span class="sd">        ### Args:</span>
<span class="sd">        - `input` - señal eléctrica a filtrar</span>
<span class="sd">        - `BW` - ancho de banda del filtro en [Hz]</span>
<span class="sd">        - `n` [Opcional] - orden del filtro (default: `n=4`)</span>
<span class="sd">        - `fs` [Opcional] - frecuencia de muestreo de la señal de entrada (default: `fs=globals_vars.fs`)</span>
<span class="sd">        </span>
<span class="sd">        ---</span>
<span class="sd">        </span>
<span class="sd">        ### Returns:</span>
<span class="sd">        - `electrical_signal`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tic</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`input` debe ser del tipo (ndarray ó electrical_signal).&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">input</span> <span class="o">=</span> <span class="n">electrical_signal</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fs</span><span class="p">:</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">global_vars</span><span class="o">.</span><span class="n">fs</span>

        <span class="n">sos_band</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">bessel</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="n">n</span><span class="p">,</span> <span class="n">Wn</span> <span class="o">=</span> <span class="n">BW</span><span class="p">,</span> <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;sos&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span><span class="p">)</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">electrical_signal</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">())</span> <span class="p">)</span>

        <span class="n">output</span><span class="o">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos_band</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">):</span>
            <span class="n">output</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos_band</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">)</span>
        
        <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="PD">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.PD">[docs]</a>
<span class="k">def</span> <span class="nf">PD</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">responsivity</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">300.0</span><span class="p">,</span> <span class="n">R_load</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">50.0</span><span class="p">,</span> <span class="n">noise</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;ase-only&#39;</span><span class="p">,</span><span class="s1">&#39;thermal-only&#39;</span><span class="p">,</span><span class="s1">&#39;shot-only&#39;</span><span class="p">,</span><span class="s1">&#39;ase-thermal&#39;</span><span class="p">,</span><span class="s1">&#39;ase-shot&#39;</span><span class="p">,</span><span class="s1">&#39;thermal-shot&#39;</span><span class="p">,</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">electrical_signal</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Photodetector. Simula la detección de una señal óptica por un fotodetector.</span>
<span class="sd">    </span>
<span class="sd">    ---</span>

<span class="sd">    ### Args:</span>
<span class="sd">    - `input` - señal óptica a detectar</span>
<span class="sd">    - `BW` - ancho de banda del detector en [Hz]</span>
<span class="sd">    - `responsivity` [Opcional] - Responsividad del detector en [A/W] (default: `R=1.0`)</span>
<span class="sd">    - `T` [Opcional] - Temperatura del detector en [K] (default: `T=300.0`)</span>
<span class="sd">    - `R_load` [Opcional] - Resistencia de carga del detector en [Ohm] (default: `R_load=50.0`)</span>
<span class="sd">    </span>
<span class="sd">    ---</span>
<span class="sd">    </span>
<span class="sd">    ### Returns:</span>
<span class="sd">    - `electrical_signal`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>

    <span class="n">i_sig</span> <span class="o">=</span> <span class="n">responsivity</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="s1">&#39;signal&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># se suman las dos polarizaciones</span>

    <span class="k">if</span> <span class="s1">&#39;thermal&#39;</span> <span class="ow">in</span> <span class="n">noise</span> <span class="ow">or</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="n">noise</span><span class="p">:</span>
        <span class="n">S_T</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">kB</span> <span class="o">*</span> <span class="n">T</span> <span class="o">*</span> <span class="n">BW</span> <span class="o">/</span> <span class="n">R_load</span> <span class="c1"># Density of thermal noise in [A^2]</span>
        <span class="n">i_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">S_T</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">())</span>
    
    <span class="k">if</span> <span class="s1">&#39;shot&#39;</span> <span class="ow">in</span> <span class="n">noise</span> <span class="ow">or</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="n">noise</span><span class="p">:</span>
        <span class="n">S_N</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">e</span> <span class="o">*</span> <span class="n">i_sig</span> <span class="o">*</span> <span class="n">BW</span> <span class="c1"># Density of shot noise in [A^2]</span>
        <span class="n">i_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="p">))(</span><span class="n">S_N</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;ase&#39;</span> <span class="ow">in</span> <span class="n">noise</span> <span class="ow">or</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="n">noise</span><span class="p">:</span>
        <span class="n">i_sig_sp</span> <span class="o">=</span> <span class="n">responsivity</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">+</span> \
                            <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                            <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">+</span> \
                            <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">i_sp_sp</span> <span class="o">=</span> <span class="n">responsivity</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="s1">&#39;noise&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># se suman las dos polarizaciones</span>

    <span class="k">if</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;ase-only&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_sig_sp</span>  <span class="o">+</span> <span class="n">i_sp_sp</span>
    <span class="k">elif</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;thermal-only&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_T</span> 
    <span class="k">elif</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;shot-only&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_N</span>
    <span class="k">elif</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;ase-shot&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_sig_sp</span>  <span class="o">+</span> <span class="n">i_sp_sp</span> <span class="o">+</span> <span class="n">i_N</span> 
    <span class="k">elif</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;ase-thermal&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_sig_sp</span>  <span class="o">+</span> <span class="n">i_sp_sp</span> <span class="o">+</span> <span class="n">i_T</span> 
    <span class="k">elif</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;thermal-shot&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_T</span> <span class="o">+</span> <span class="n">i_N</span> 
    <span class="k">elif</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_sig_sp</span>  <span class="o">+</span> <span class="n">i_sp_sp</span> <span class="o">+</span> <span class="n">i_N</span> <span class="o">+</span> <span class="n">i_T</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;El argumento `noise` debe ser uno de los siguientes: &#39;ase-only&#39;,&#39;thermal-only&#39;,&#39;shot-only&#39;,&#39;ase-thermal&#39;,&#39;ase-shot&#39;,&#39;thermal-shot&#39;,&#39;all&#39;.&quot;</span><span class="p">)</span>
    
    <span class="n">time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="n">filt</span> <span class="o">=</span> <span class="n">LPF</span><span class="p">(</span><span class="n">i_sig</span><span class="p">,</span> <span class="n">BW</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">electrical_signal</span><span class="p">(</span><span class="n">filt</span><span class="o">.</span><span class="n">signal</span><span class="p">,</span> <span class="n">noise</span><span class="p">)</span>

    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">filt</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">+</span> <span class="n">time</span>
    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="ADC">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.ADC">[docs]</a>
<span class="k">def</span> <span class="nf">ADC</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">electrical_signal</span><span class="p">,</span> <span class="n">fs</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nbits</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">binary_sequence</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Conversor analógico a digital. Convierte una señal eléctrica analógica en una señal digital de amplitud cuantizada, muestreada a una frecuencia `fs`</span>
<span class="sd">    y filtrada a un ancho de banda BW.</span>

<span class="sd">    ---</span>

<span class="sd">    ### Args:</span>
<span class="sd">    - `input` - señal eléctrica a cuantizar</span>
<span class="sd">    - `fs` [Opcional] - frecuencia de muestreo de la señal de salida (default: `global_vars.fs`)</span>
<span class="sd">    - `BW` [Opcional] - ancho de banda del ADC en [Hz] (default: `inf` no se filtra la señal)</span>
<span class="sd">    - `nbits` [Opcional] - cantidad de bits del ADC (default: `nbits=8`)</span>

<span class="sd">    ---</span>
<span class="sd">    </span>
<span class="sd">    ### Returns:</span>
<span class="sd">    - `electrical_signal`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`input` debe ser del tipo (electrical_signal).&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">fs</span><span class="p">:</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">global_vars</span><span class="o">.</span><span class="n">fs</span>

    <span class="k">if</span> <span class="n">BW</span><span class="p">:</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">bessel</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">Wn</span> <span class="o">=</span> <span class="n">BW</span><span class="p">,</span> <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">fs</span><span class="p">(),</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;sos&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span><span class="p">)</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">signal</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span>

    <span class="n">signal</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span><span class="o">*</span><span class="n">fs</span><span class="o">/</span><span class="nb">input</span><span class="o">.</span><span class="n">fs</span><span class="p">()))</span>

    <span class="n">V_min</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">V_max</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">dig_signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span> <span class="p">(</span><span class="n">signal</span> <span class="o">-</span> <span class="n">V_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">V_max</span> <span class="o">-</span> <span class="n">V_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="c1"># normalizo la señal entre 0 y 2**nbits-1</span>
    <span class="n">dig_signal</span> <span class="o">=</span> <span class="n">dig_signal</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">V_max</span> <span class="o">-</span> <span class="n">V_min</span><span class="p">)</span> <span class="o">+</span> <span class="n">V_min</span> <span class="c1"># vuelvo a la amplitud original</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">):</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">)</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span><span class="o">*</span><span class="n">fs</span><span class="o">//</span><span class="nb">input</span><span class="o">.</span><span class="n">fs</span><span class="p">()))</span>
        <span class="n">V_min</span> <span class="o">=</span> <span class="n">noise</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">V_max</span> <span class="o">=</span> <span class="n">noise</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">dig_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span> <span class="p">(</span><span class="n">noise</span> <span class="o">-</span> <span class="n">V_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">V_max</span> <span class="o">-</span> <span class="n">V_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="c1"># normalizo la señal entre 0 y 2**nbits-1</span>
        <span class="n">dig_noise</span> <span class="o">=</span> <span class="n">dig_noise</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">V_max</span> <span class="o">-</span> <span class="n">V_min</span><span class="p">)</span> <span class="o">+</span> <span class="n">V_min</span> <span class="c1"># vuelvo a la amplitud original</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">electrical_signal</span><span class="p">(</span> <span class="n">dig_signal</span><span class="p">,</span> <span class="n">dig_noise</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">electrical_signal</span><span class="p">(</span> <span class="n">dig_signal</span> <span class="p">)</span>

    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="GET_EYE">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.GET_EYE">[docs]</a>
<span class="k">def</span> <span class="nf">GET_EYE</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">electrical_signal</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">],</span> <span class="n">nslots</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span> <span class="n">sps_resamplig</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estima todos los parámetros fundamentales y métricas del diagrama de ojo de la señal eléctrica de entrada.</span>
<span class="sd">    </span>
<span class="sd">    ---</span>

<span class="sd">    ### Args:</span>
<span class="sd">    - `input` - señal eléctrica a partir de la cual se estimará el diagrama de ojos</span>
<span class="sd">    - `nslots` [Opcional] - cantidad de slots a considerar para la estimación de los parámetros (default: `nslots=4096`)</span>
<span class="sd">    - `sps_resamplig` [Opcional] - cantidad de muestras por slot a las que se desea resamplear la señal a analizar (default: `global_vars.sps`)</span>
<span class="sd">    </span>
<span class="sd">    ---</span>
<span class="sd">    </span>
<span class="sd">    ### Returns:</span>
<span class="sd">    - `eye` - objeto de la clase `Eye` con todos los parámetros y métricas del diagrama de ojo</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">shorth_int</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimación del intervalo más corto que contiene el 50% de las muestras de &#39;data&#39;.</span>
<span class="sd">        </span>
<span class="sd">        ---</span>
<span class="sd">        </span>
<span class="sd">        ### Args:</span>
<span class="sd">        - `data` - array de datos</span>

<span class="sd">        ---</span>

<span class="sd">        ### Returns:</span>
<span class="sd">        - `tuple[float, float]` - intervalo más corto que contiene el 50% de las muestras de &#39;data&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">diff_lag</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">data</span><span class="p">,</span><span class="n">lag</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="n">lag</span><span class="p">:]</span><span class="o">-</span><span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="n">lag</span><span class="p">]</span>  <span class="c1"># Diferencia entre dos elemento de un array separados una distancia &#39;lag&#39;</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">lag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">diff_lag</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">lag</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span><span class="o">&lt;</span><span class="mf">1e-10</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">lag</span><span class="p">])</span>
    
    <span class="k">def</span> <span class="nf">find_nearest</span><span class="p">(</span><span class="n">levels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Encuentra el elemento de &#39;levels&#39; más cercano a cada valor de &#39;data&#39;.</span>
<span class="sd">        </span>
<span class="sd">        ---</span>

<span class="sd">        ### Args:</span>
<span class="sd">        - `levels` - niveles de referencia.</span>
<span class="sd">        - `data` - valores a comparar.</span>

<span class="sd">        ### Returns:</span>
<span class="sd">        - `Union[ndarray, float]` - vector o float con los valores de &#39;levels&#39; correspondientes a cada valor de &#39;data&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">levels</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">levels</span> <span class="o">-</span> <span class="n">data</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">levels</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">levels</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">,(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)]</span>

    <span class="n">eye_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">sps</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">sps</span><span class="p">();</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;sps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sps</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">dt</span><span class="p">();</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt</span>

    
    <span class="n">n</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">sps</span><span class="p">:]</span><span class="o">.</span><span class="n">len</span><span class="p">()</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">sps</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">n</span><span class="p">:</span> <span class="nb">input</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">sps</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">]</span>
    
    <span class="n">nslots</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span><span class="o">//</span><span class="n">sps</span><span class="o">//</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">nslots</span><span class="p">)</span>
    <span class="nb">input</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[:</span><span class="n">nslots</span><span class="o">*</span><span class="n">sps</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">):</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="o">+</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;El argumento &#39;input&#39; debe ser de la clase &#39;optical_signal&#39; o &#39;electrical_signal&#39;.&quot;</span><span class="p">)</span>

    <span class="nb">input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="o">-</span><span class="n">sps</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Para centrar el ojo en el gráfico</span>
    <span class="n">y_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>

    <span class="c1"># realizamos un resampling de la señal para obtener una mayor resolución en ambos ejes</span>
    <span class="k">if</span> <span class="n">sps_resamplig</span><span class="p">:</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">nslots</span><span class="o">*</span><span class="n">sps_resamplig</span><span class="p">);</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nslots</span><span class="o">//</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">dt</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">sps_resamplig</span><span class="p">));</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span><span class="o">//</span><span class="n">sps</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">dt</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">sps</span><span class="p">));</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>

    <span class="c1"># Obtenemos el centroide de las muestras en el eje Y</span>
    <span class="n">vm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">)</span>

    <span class="c1"># obtenemos el intervalo más corto de la mitad superior que contiene al 50% de las muestras</span>
    <span class="n">top_int</span> <span class="o">=</span> <span class="n">shorth_int</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="nb">input</span><span class="o">&gt;</span><span class="n">vm</span><span class="p">])</span> 
    <span class="c1"># Obtenemos el LMS del nivel 1</span>
    <span class="n">state_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">top_int</span><span class="p">)</span>
    <span class="c1"># obtenemos el intervalo más corto de la mitad inferior que contiene al 50% de las muestras</span>
    <span class="n">bot_int</span> <span class="o">=</span> <span class="n">shorth_int</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="nb">input</span><span class="o">&lt;</span><span class="n">vm</span><span class="p">])</span>
    <span class="c1"># Obtenemos el LMS del nivel 0</span>
    <span class="n">state_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bot_int</span><span class="p">)</span>

    <span class="c1"># Obtenemos la amplitud entre los dos niveles 0 y 1</span>
    <span class="n">d01</span> <span class="o">=</span> <span class="n">state_1</span> <span class="o">-</span> <span class="n">state_0</span>

    <span class="c1"># Tomamos el 75% de nivel de umbral</span>
    <span class="n">v75</span> <span class="o">=</span> <span class="n">state_1</span> <span class="o">-</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">d01</span>

    <span class="c1"># Tomamos el 25% de nivel de umbral</span>
    <span class="n">v25</span> <span class="o">=</span> <span class="n">state_0</span> <span class="o">+</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">d01</span>

    <span class="n">t_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>

    <span class="c1"># El siguiente vector se utilizará solo para determinar los tiempos de cruce</span>
    <span class="n">tt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[(</span><span class="nb">input</span><span class="o">&gt;</span><span class="n">v25</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="nb">input</span><span class="o">&lt;</span><span class="n">v75</span><span class="p">)]</span>

    <span class="c1"># Obtenemos el centroide de los datos de tiempo</span>
    <span class="n">tm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">)</span>

    <span class="c1"># Obtenemos el tiempo de cruce por la izquierda</span>
    <span class="n">t_left</span> <span class="o">=</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">t_set</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tt</span><span class="p">[</span><span class="n">tt</span><span class="o">&lt;</span><span class="n">tm</span><span class="p">]));</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_left&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_left</span>

    <span class="c1"># Obtenemos el tiempo de cruce por la derecha</span>
    <span class="n">t_right</span> <span class="o">=</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">t_set</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tt</span><span class="p">[</span><span class="n">tt</span><span class="o">&gt;</span><span class="n">tm</span><span class="p">]));</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_right</span>

    <span class="c1"># Determinamos el centro del ojo</span>
    <span class="n">t_center</span> <span class="o">=</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">t_set</span><span class="p">,</span> <span class="p">(</span><span class="n">t_left</span> <span class="o">+</span> <span class="n">t_right</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_opt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_center</span>

    <span class="c1"># Para el 20% del centro del diagrama de ojo</span>
    <span class="n">t_dist</span> <span class="o">=</span> <span class="n">t_right</span> <span class="o">-</span> <span class="n">t_left</span><span class="p">;</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_dist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_dist</span>
    <span class="n">t_span0</span> <span class="o">=</span> <span class="n">t_center</span> <span class="o">-</span> <span class="mf">0.05</span><span class="o">*</span><span class="n">t_dist</span><span class="p">;</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_span0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_span0</span>
    <span class="n">t_span1</span> <span class="o">=</span> <span class="n">t_center</span> <span class="o">+</span> <span class="mf">0.05</span><span class="o">*</span><span class="n">t_dist</span><span class="p">;</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_span1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_span1</span>

    <span class="c1"># Dentro del 20% de los datos del centro del diagrama de ojo, separamos en dos clusters superior e inferior</span>
    <span class="n">y_center</span> <span class="o">=</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">y_set</span><span class="p">,</span> <span class="p">(</span><span class="n">state_0</span> <span class="o">+</span> <span class="n">state_1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Obtenemos el instante óptimo para realizar el down sampling</span>
    <span class="k">if</span> <span class="n">sps_resamplig</span><span class="p">:</span>
        <span class="n">instant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t_center</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span> <span class="o">-</span> <span class="n">sps_resamplig</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">instant</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">instant</span><span class="o">/</span><span class="n">sps_resamplig</span><span class="o">*</span><span class="n">sps</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">instant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t_center</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span> <span class="o">-</span> <span class="n">sps</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">instant</span>

    <span class="c1"># Obtenemos el cluster superior</span>
    <span class="n">y_top</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[(</span><span class="nb">input</span> <span class="o">&gt;</span> <span class="n">y_center</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">t_span0</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_span1</span><span class="p">))];</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;y_top&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_top</span>

    <span class="c1"># Obtenemos el cluster inferior</span>
    <span class="n">y_bot</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[(</span><span class="nb">input</span> <span class="o">&lt;</span> <span class="n">y_center</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">t_span0</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_span1</span><span class="p">))];</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;y_bot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_bot</span>

    <span class="c1"># Para cada cluster calculamos las medias y desviaciones estándar</span>
    <span class="n">mu1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_top</span><span class="p">);</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;mu1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu1</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">y_top</span><span class="p">);</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;s1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s1</span>
    <span class="n">mu0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_bot</span><span class="p">);</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;mu0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu0</span>
    <span class="n">s0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">y_bot</span><span class="p">);</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;s0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s0</span>

    <span class="c1"># Obtenemos la relación de extinción</span>
    <span class="n">er</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">mu1</span><span class="o">/</span><span class="n">mu0</span><span class="p">)</span> <span class="k">if</span> <span class="n">mu0</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">;</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;er&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">er</span>

    <span class="c1"># Obtenemos la apertura del ojo</span>
    <span class="n">eye_h</span> <span class="o">=</span> <span class="n">mu1</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">s1</span> <span class="o">-</span> <span class="n">mu0</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">s0</span><span class="p">;</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;eye_h&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eye_h</span>

    <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;ejecution_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">eye</span><span class="p">(</span><span class="n">eye_dict</span><span class="p">)</span></div>



<div class="viewcode-block" id="SAMPLER">
<a class="viewcode-back" href="../../modules.html#opticomlib.devices.SAMPLER">[docs]</a>
<span class="k">def</span> <span class="nf">SAMPLER</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">electrical_signal</span><span class="p">,</span> <span class="n">_eye_</span><span class="p">:</span> <span class="n">eye</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">electrical_signal</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recibe una señal de tipo `electrical_signal` y un objeto de tipo `eye` y realiza el muestreo de la señal </span>
<span class="sd">    en el instante óptimo determinado por el objeto `eye`.</span>
<span class="sd">    </span>
<span class="sd">    ---</span>

<span class="sd">    ### Args:</span>
<span class="sd">    - `input` - señal eléctrica a muestrear</span>
<span class="sd">    - `eye`  - objeto de tipo `eye` que contiene la información del diagrama de ojo</span>

<span class="sd">    ### Returns:</span>
<span class="sd">    - `electrical_signal` - señal electrica muestreada a una muestra por slot</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>
    <span class="n">output</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">_eye_</span><span class="o">.</span><span class="n">i</span><span class="p">::</span><span class="n">_eye_</span><span class="o">.</span><span class="n">sps</span><span class="p">]</span>

    <span class="n">output</span><span class="o">.</span><span class="n">ejecution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>







<span class="c1">### algunas funciones de prueba</span>
<span class="k">def</span> <span class="nf">animated_fiber_propagation</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> <span class="n">M</span> <span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">length_</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">alpha_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">beta_2_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">beta_3_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">gamma_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">phi_max</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">matplotlib.animation</span> <span class="kn">import</span> <span class="n">FuncAnimation</span>

    <span class="c1"># cambio las unidades</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">length_</span> <span class="o">*</span> <span class="mf">1e3</span> 
    <span class="n">alpha</span>  <span class="o">=</span> <span class="n">alpha_</span> <span class="o">*</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mf">4.343</span><span class="o">*</span><span class="mf">1e3</span><span class="p">)</span>
    <span class="n">beta_2</span> <span class="o">=</span> <span class="n">beta_2_</span> <span class="o">*</span> <span class="mf">1e-12</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">1e3</span>
    <span class="n">beta_3</span> <span class="o">=</span> <span class="n">beta_3_</span> <span class="o">*</span> <span class="mf">1e-12</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mf">1e3</span>
    <span class="n">gamma</span>  <span class="o">=</span> <span class="n">gamma_</span> <span class="o">*</span> <span class="mi">1</span><span class="o">/</span><span class="mf">1e3</span>

    <span class="n">w</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">w</span><span class="p">()</span>
    <span class="n">D_op</span> <span class="o">=</span> <span class="o">-</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">beta_2</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">6</span> <span class="o">*</span> <span class="n">beta_3</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">3</span>

    <span class="n">A</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="k">if</span> <span class="p">(</span><span class="n">beta_2</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">beta_3</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">gamma</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="n">phi_max</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="n">x_length</span> <span class="o">=</span> <span class="n">h</span>
    <span class="n">A_z</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">]</span>
    <span class="n">hs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">exp_NL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D_op</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span> <span class="n">exp_L</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">A_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">hs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">phi_max</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">if</span> <span class="n">gamma</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">length</span> 

        <span class="k">if</span> <span class="n">x_length</span> <span class="o">+</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">x_length</span> <span class="o">+=</span> <span class="n">h</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">x_length</span>
    
    <span class="k">if</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">exp_NL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D_op</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span> <span class="n">exp_L</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">A_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">hs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">t</span><span class="p">()</span><span class="o">*</span><span class="n">global_vars</span><span class="o">.</span><span class="n">slot_rate</span>

    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

    <span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
    <span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Fiber: $\alpha = </span><span class="si">{:.2f}</span><span class="s1">$ dB/km, $\beta_2 = </span><span class="si">{}</span><span class="s1">$ ps^2/km, $\gamma = </span><span class="si">{}</span><span class="s1">$ (W·km)^-1&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">alpha_</span><span class="p">,</span> <span class="n">beta_2_</span><span class="p">,</span> <span class="n">gamma_</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$t/T_</span><span class="si">{slot}</span><span class="s1">$&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;|A(z,t)|&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">*</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1.05</span><span class="p">))</span>

    <span class="n">time_text</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span><span class="mf">0.9</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
        <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">([],[])</span>
        <span class="n">time_text</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s1">&#39;z = 0.0 Km&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[::</span><span class="n">M</span><span class="o">*</span><span class="n">global_vars</span><span class="o">.</span><span class="n">sps</span><span class="p">]:</span>
           <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[::</span><span class="n">global_vars</span><span class="o">.</span><span class="n">sps</span><span class="p">]:</span>
           <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">line</span><span class="p">,</span> <span class="n">time_text</span><span class="p">]</span> 

    <span class="k">def</span> <span class="nf">animate</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">time_text</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s1">&#39;z = </span><span class="si">{:.2f}</span><span class="s1"> Km&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">hs</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mf">1e3</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">line</span><span class="p">,</span> <span class="n">time_text</span><span class="p">]</span> 

    <span class="n">anim</span> <span class="o">=</span> <span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">animate</span><span class="p">,</span> <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">A_z</span><span class="p">),</span> <span class="n">interval</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">animated_fiber_propagation_with_psd</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> <span class="n">M</span> <span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">length_</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">alpha_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">beta_2_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">beta_3_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">gamma_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">phi_max</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">matplotlib.animation</span> <span class="kn">import</span> <span class="n">FuncAnimation</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">n</span><span class="o">*</span><span class="n">M</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">sps</span><span class="p">()</span> 
    
    <span class="n">length</span> <span class="o">=</span> <span class="n">length_</span>
    <span class="n">alpha</span>  <span class="o">=</span> <span class="n">alpha_</span><span class="o">/</span><span class="mf">4.343</span>
    <span class="n">beta_2</span> <span class="o">=</span> <span class="n">beta_2_</span>
    <span class="n">beta_3</span> <span class="o">=</span> <span class="n">beta_3_</span>
    <span class="n">gamma</span>  <span class="o">=</span> <span class="n">gamma_</span>

    <span class="n">w</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">w</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e-12</span> <span class="c1"># rad/ps</span>
    <span class="n">D_op</span> <span class="o">=</span> <span class="o">-</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">beta_2</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">6</span> <span class="o">*</span> <span class="n">beta_3</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">3</span>

    <span class="n">A</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="k">if</span> <span class="p">(</span><span class="n">beta_2</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">beta_3</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">gamma</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="n">phi_max</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="n">x_length</span> <span class="o">=</span> <span class="n">h</span>
    <span class="n">A_z</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">]</span>
    <span class="n">A_z_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">fft</span><span class="p">(</span><span class="n">A</span><span class="p">)]</span>
    <span class="n">hs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">exp_NL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D_op</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span> <span class="n">exp_L</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">A_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">x_length</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">A_z_w</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fft</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">x_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">hs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">phi_max</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">if</span> <span class="n">gamma</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">length</span> 

        <span class="k">if</span> <span class="n">x_length</span> <span class="o">+</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">x_length</span> <span class="o">+=</span> <span class="n">h</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">x_length</span>
    
    <span class="k">if</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">exp_NL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D_op</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span> <span class="n">exp_L</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">A_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">length</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">A_z_w</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fft</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">length</span><span class="o">/</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">hs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">t</span><span class="p">()</span><span class="o">*</span><span class="n">global_vars</span><span class="o">.</span><span class="n">slot_rate</span>

    <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span><span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>

    <span class="n">line1</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">[</span><span class="mi">0</span><span class="p">])[:</span><span class="n">n</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
    <span class="n">line1</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Fiber: $\alpha = </span><span class="si">{:.2f}</span><span class="s1">$ dB/km, $\beta_2 = </span><span class="si">{}</span><span class="s1">$ ps^2/km, $\gamma = </span><span class="si">{}</span><span class="s1">$ (W·km)^-1&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">alpha_</span><span class="p">,</span> <span class="n">beta_2_</span><span class="p">,</span> <span class="n">gamma_</span><span class="p">))</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;t/T&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;|A(z,t)|&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">[:</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>

    <span class="n">z_text</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span><span class="mf">0.9</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="mf">1e3</span> <span class="c1"># GHz</span>

    <span class="n">line2</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z_w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">(),</span> <span class="s1">&#39;--g&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">line2</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;f [GHz]&#39;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$|A(z,w)|^2$&#39;</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="o">-</span><span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A_z_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.001</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z_w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="p">))</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z_w</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="mf">1.05</span><span class="o">/</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()))</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
        <span class="n">line1</span><span class="o">.</span><span class="n">set_data</span><span class="p">([],[])</span>
        <span class="n">z_text</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s1">&#39;z = 0.0 Km&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[:</span><span class="n">n</span><span class="p">:</span><span class="n">M</span><span class="o">*</span><span class="n">global_vars</span><span class="o">.</span><span class="n">sps</span><span class="p">]:</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[:</span><span class="n">n</span><span class="p">:</span><span class="n">global_vars</span><span class="o">.</span><span class="n">sps</span><span class="p">]:</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">line1</span><span class="p">,</span> <span class="n">z_text</span><span class="p">]</span> 

    <span class="k">def</span> <span class="nf">animate</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">line1</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">y</span><span class="p">[:</span><span class="n">n</span><span class="p">])</span>
        <span class="n">z_text</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s1">&#39;z = </span><span class="si">{:.2f}</span><span class="s1"> Km&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">hs</span><span class="p">)[</span><span class="n">i</span><span class="p">]))</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z_w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span>
        <span class="n">line2</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">line1</span><span class="p">,</span> <span class="n">line2</span><span class="p">,</span> <span class="n">z_text</span><span class="p">]</span> 

    <span class="n">anim</span> <span class="o">=</span> <span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">animate</span><span class="p">,</span> <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">A_z</span><span class="p">),</span> <span class="n">interval</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># def Spectrogram(signal, T_L):</span>
    <span class="c1">#     N = signal.len()//T_L</span>
    <span class="c1">#     y = np.zeros(N*T_L)</span>
    <span class="c1">#     for i in range(N):</span>
    <span class="c1">#         y[i*T_L:(i+1)*T_L] = fftshift(np.abs( fft(signal.signal[i*T_L:(i+1)*T_L]) )**2)</span>
    <span class="c1">#     y = y.reshape((N, T_L)).T</span>
    <span class="c1">#     return y</span>


    <span class="c1"># sps = 2048</span>
    <span class="c1"># global_vars(M=8, sps=sps, R=10e9)</span>
    <span class="c1"># y = DAC(&#39;0 1 0 1 0 0 1&#39;, pulse_shape=&#39;gaussian&#39;, T=sps, m=1, c=-50)</span>
    <span class="c1"># N_TL = 128</span>
    <span class="c1"># # g = Spectrogram(y, N_TL)</span>
    <span class="c1"># # f = y.w()/(2*np.pi)</span>
    <span class="c1"># # plt.imshow(g, cmap=&#39;hot&#39;, aspect=&#39;auto&#39;, interpolation=&#39;blackman&#39;, extent=[y.t().min()*1e9, y.t().max()*1e9, f.min()*1e-9, f.max()*1e-9])</span>
    <span class="c1"># # plt.ylim(-1000,1000)</span>
    <span class="c1"># # y.plot(ylabel=&#39;Voltaje (V)&#39;,c=&#39;red&#39;).grid()</span>
    <span class="c1"># plt.figure()</span>
    <span class="c1"># plt.plot(y.t(), y.abs(&#39;signal&#39;))</span>
    <span class="c1"># # for i in range(y.len()//N_TL):</span>
    <span class="c1"># #     plt.axvline(y.t()[i*N_TL], ls=&#39;--&#39;)</span>
    <span class="c1"># plt.show()</span>
    <span class="k">pass</span>



</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Ing. Armando P. Romeu.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>