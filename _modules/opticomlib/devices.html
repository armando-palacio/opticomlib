<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>opticomlib.devices &mdash; opticomlib  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/fonts.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon_laser.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            opticomlib
              <img src="../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.4.4
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html#usage">Usage</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">OptiComLib Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../types.html">Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devices.html">Electro-Optical Devices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ook.html">OOK Devices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ppm.html">PPM Devices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../lab.html">Laboratory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utils.html">Utilities functions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">opticomlib</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">opticomlib.devices</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for opticomlib.devices</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. rubric:: Devices</span>
<span class="sd">.. autosummary::</span>

<span class="sd">   PRBS                  </span>
<span class="sd">   DAC                   </span>
<span class="sd">   PM                    </span>
<span class="sd">   MZM                   </span>
<span class="sd">   BPF                   </span>
<span class="sd">   EDFA                  </span>
<span class="sd">   DM                    </span>
<span class="sd">   FIBER                 </span>
<span class="sd">   LPF                   </span>
<span class="sd">   PD                    </span>
<span class="sd">   ADC                   </span>
<span class="sd">   GET_EYE               </span>
<span class="sd">   SAMPLER               </span>
<span class="sd">   FBG                   </span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="sd">&quot;&quot;&quot;Basic physical models for optical/electronic components.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">sg</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">solve_ivp</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">scipy.constants</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">k</span> <span class="k">as</span> <span class="n">kB</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">c</span>
<span class="kn">from</span> <span class="nn">numpy.fft</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">ifft</span><span class="p">,</span> <span class="n">fftshift</span><span class="p">,</span> <span class="n">ifftshift</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.family&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;serif&#39;</span> 

<span class="kn">import</span> <span class="nn">sklearn.cluster</span> <span class="k">as</span> <span class="nn">sk</span>
<span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span> <span class="c1"># progress bar</span>

<span class="kn">import</span> <span class="nn">warnings</span>


<span class="kn">from</span> <span class="nn">.typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">electrical_signal</span><span class="p">,</span>
    <span class="n">binary_sequence</span><span class="p">,</span>
    <span class="n">optical_signal</span><span class="p">,</span>
    <span class="n">gv</span><span class="p">,</span>
    <span class="n">eye</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">idbm</span><span class="p">,</span>
    <span class="n">idb</span><span class="p">,</span>
    <span class="n">db</span><span class="p">,</span>
    <span class="n">tic</span><span class="p">,</span>
    <span class="n">toc</span><span class="p">,</span>
    <span class="n">rcos</span><span class="p">,</span>
    <span class="n">si</span><span class="p">,</span>
    <span class="n">tau_g</span><span class="p">,</span>
    <span class="n">bode</span><span class="p">,</span>
    <span class="n">dispersion</span><span class="p">,</span>
<span class="p">)</span>

<div class="viewcode-block" id="PRBS">
<a class="viewcode-back" href="../../devices.html#opticomlib.devices.PRBS">[docs]</a>
<span class="k">def</span> <span class="nf">PRBS</span><span class="p">(</span><span class="n">order</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">31</span><span class="p">],</span> 
         <span class="nb">len</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
         <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
         <span class="n">return_seed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;**Pseudorandom binary sequence generator**</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    order : :obj:`int`, {7, 9, 11, 15, 20, 23, 31}</span>
<span class="sd">        degree of the generating pseudorandom polynomial</span>
<span class="sd">    len : :obj:`int`, optional</span>
<span class="sd">        lenght of output binary sequence</span>
<span class="sd">    seed : :obj:`int`, optional</span>
<span class="sd">        seed of the generator (initial state of the LFSR). It must be provided if you want to continue the sequence.</span>
<span class="sd">        Default is 2**order-1.</span>
<span class="sd">    return_seed : :obj:`bool`, optional</span>
<span class="sd">        If True, the last state of LFSR is returned. Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : :obj:`binary_sequence`</span>
<span class="sd">        generated pseudorandom binary sequence</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If ``order`` is not in [7, 9, 11, 15, 20, 23, 31].</span>
<span class="sd">    TypeError</span>
<span class="sd">        If ``len`` is not an integer.</span>
<span class="sd">    </span>
<span class="sd">    Warns</span>
<span class="sd">    -----</span>
<span class="sd">    UserWarning</span>
<span class="sd">        If the seed is 0 or a multiple of 2**order.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    You can generate a PRBS sequence using the following code:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; from opticomlib.devices import PRBS</span>
<span class="sd">    &gt;&gt;&gt; PRBS(order=7, len=10)</span>
<span class="sd">    binary_sequence([1 0 0 0 0 0 0 1 0 0])</span>
<span class="sd">    &gt;&gt;&gt; PRBS(order=31, len=20)</span>
<span class="sd">    binary_sequence([1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</span>

<span class="sd">    You can fix the LFSR iniitial state of generator by using the following code:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; PRBS(order=7, len=10, seed=124)</span>
<span class="sd">    binary_sequence([0 0 0 0 0 1 0 0 0 0])</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For more details, see [prbs]_.</span>

<span class="sd">    - :math:`2^7-1` bits. Polynomial :math:`= X^7 + X^6 + 1`</span>
<span class="sd">    - :math:`2^9-1` bits. Polynomial :math:`= X^9 + X^5 + 1`</span>
<span class="sd">    - :math:`2^{11}-1` bits. Polynomial :math:`= X^{11} + X^9 + 1`</span>
<span class="sd">    - :math:`2^{15}-1` bits. Polynomial :math:`= X^{15} + X^{14} + 1`</span>
<span class="sd">    - :math:`2^{20}-1` bits. Polynomial :math:`= X^{20} + X^3 + 1`</span>
<span class="sd">    - :math:`2^{23}-1` bits. Polynomial :math:`= X^{23} + X^{18} + 1`</span>
<span class="sd">    - :math:`2^{31}-1` bits. Polynomial :math:`= X^{31} + X^{28} + 1`</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [prbs] &quot;Pseudorandom binary sequence&quot; https://en.wikipedia.org/wiki/Pseudorandom_binary_sequence</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>
    <span class="n">taps</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="mi">9</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">11</span><span class="p">:</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="mi">15</span><span class="p">:</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span><span class="mi">14</span><span class="p">],</span> <span class="mi">20</span><span class="p">:</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">23</span><span class="p">:</span> <span class="p">[</span><span class="mi">23</span><span class="p">,</span><span class="mi">18</span><span class="p">],</span> <span class="mi">31</span><span class="p">:</span> <span class="p">[</span><span class="mi">31</span><span class="p">,</span><span class="mi">28</span><span class="p">]}</span>
    <span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">order</span><span class="p">)</span> <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">order</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The seed can</span><span class="se">\&#39;</span><span class="s1">t be 0 or a multiple of 2**order. It has been changed to 1.&#39;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The parameter `len` must be an integer.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The parameter `len` must be an integer greater than cero.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">len</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">order</span><span class="o">-</span><span class="mi">1</span>
    
    <span class="k">if</span> <span class="n">order</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">taps</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The parameter `order` must be one of the following values (7, 9, 11, 15, 20, 23, 31).&#39;</span><span class="p">)</span>

    <span class="n">prbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>  <span class="c1"># Preallocate memory for the PRBS</span>
    <span class="n">lfsr</span> <span class="o">=</span> <span class="n">seed</span> <span class="c1"># initial state of the LFSR </span>
    <span class="n">tap1</span><span class="p">,</span> <span class="n">tap2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">taps</span><span class="p">[</span><span class="n">order</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>

    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">:</span>
        <span class="n">prbs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">lfsr</span><span class="o">&amp;</span><span class="mi">1</span>
        <span class="n">new</span> <span class="o">=</span> <span class="p">((</span><span class="n">lfsr</span><span class="o">&gt;&gt;</span><span class="n">tap1</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="n">lfsr</span><span class="o">&gt;&gt;</span><span class="n">tap2</span><span class="p">))</span><span class="o">&amp;</span><span class="mi">1</span>
        <span class="n">lfsr</span> <span class="o">=</span> <span class="p">((</span><span class="n">lfsr</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">new</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">order</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> 
        <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># if lfsr == seed:</span>
        <span class="c1">#     break</span>
    
    <span class="n">output</span> <span class="o">=</span> <span class="n">binary_sequence</span><span class="p">(</span> <span class="n">prbs</span> <span class="p">)</span>
    <span class="n">output</span><span class="o">.</span><span class="n">execution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_seed</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">output</span>
    <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">lfsr</span>   </div>



<div class="viewcode-block" id="DAC">
<a class="viewcode-back" href="../../devices.html#opticomlib.devices.DAC">[docs]</a>
<span class="k">def</span> <span class="nf">DAC</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">binary_sequence</span><span class="p">,</span>
        <span class="n">bias</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">Vout</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">pulse_shape</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;nrz&#39;</span><span class="p">,</span> <span class="s1">&#39;rz&#39;</span><span class="p">,</span><span class="s1">&#39;rect&#39;</span><span class="p">,</span><span class="s1">&#39;gaussian&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;nrz&#39;</span><span class="p">,</span> 
        <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;**Digital-to-Analog Converter**</span>

<span class="sd">    Converts a binary sequence into an electrical signal, sampled at a frequency ``gv.fs``.</span>

<span class="sd">    Warning</span>
<span class="sd">    -------</span>
<span class="sd">    Parameter value ``pulse_shape=&#39;rect&#39;`` is equivalent to ``pulse_shape=&#39;nrz&#39;``. It is recommended to use ``pulse_shape=&#39;nrz&#39;``, ``&#39;rect&#39;`` will be removed in futures versions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : :obj:`str`, :obj:`list`, :obj:`tuple`, :obj:`np.ndarray`, or :obj:`binary_sequence`</span>
<span class="sd">        Input binary sequence.</span>
<span class="sd">    bias : :obj:`float`</span>
<span class="sd">        DC bias of the output signal. Default: 0.0</span>
<span class="sd">    Vout : :obj:`float`</span>
<span class="sd">        Output signal amplitude. Should be in the range [-48, 48] Volts. Default: 1.0</span>
<span class="sd">    pulse_shape : :obj:`str`, {&#39;nrz&#39;, &#39;rect&#39;, &#39;gaussian&#39;}</span>
<span class="sd">        Pulse shape at the output. Default: &#39;nrz&#39;</span>
<span class="sd">    BW : :obj:`float`</span>
<span class="sd">        Bandwidth of DAC. If ``None`` bandwidth is not limited. Default: None</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    c : :obj:`float`</span>
<span class="sd">        Chirp of the Gaussian pulse. Only applicable if ``pulse_shape=&#39;gaussian&#39;``. Default: 0.0</span>
<span class="sd">    m : :obj:`int`</span>
<span class="sd">        Order of the super-Gaussian pulse. Only applicable if ``pulse_shape=&#39;gaussian&#39;``. Default: 1</span>
<span class="sd">    T : :obj:`int`</span>
<span class="sd">        Pulse width at half maximum in number of samples. Only applicable if ``pulse_shape=&#39;gaussian&#39;``. Default: ``gv.sps``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :obj:`electrical_signal`</span>
<span class="sd">        The converted electrical signal.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If ``pulse_shape`` is not ``&#39;rect&#39;`` or ``&#39;gaussian&#39;``.</span>
<span class="sd">        If ``Vout`` is not between -48 and 48 Volts.</span>
<span class="sd">        If ``bias`` is not between -48 and 48 Volts.</span>
<span class="sd">        If ``T`` is &lt;=0 or greater than 2 times the samples per bit.</span>
<span class="sd">        If ``m`` is not a positive integer.</span>
<span class="sd">    TypeError</span>
<span class="sd">        If ``Vout`` is not a scalar value.</span>
<span class="sd">        If ``bias`` is not a scalar value.</span>
<span class="sd">        If ``c`` is not a scalar value.</span>
<span class="sd">        If ``m`` is not an integer value.</span>
<span class="sd">        If ``T`` is not an integer value.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. plot::</span>
<span class="sd">        :include-source:</span>
<span class="sd">        :alt: DAC example 1</span>
<span class="sd">        :align: center</span>

<span class="sd">        from opticomlib.devices import DAC</span>
<span class="sd">        from opticomlib import gv</span>

<span class="sd">        gv(sps=32) # set samples per bit</span>

<span class="sd">        DAC(&#39;0 0 1 0 0&#39;, Vout=5, pulse_shape=&#39;gaussian&#39;, m=2).plot(&#39;r&#39;, lw=3, grid=True).show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">binary_sequence</span><span class="p">):</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="n">binary_sequence</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
    
    <span class="n">sps</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">sps</span>

    <span class="k">if</span> <span class="n">pulse_shape</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;rect&#39;</span><span class="p">,</span> <span class="s1">&#39;nrz&#39;</span><span class="p">,</span> <span class="s1">&#39;NRZ&#39;</span><span class="p">]:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sps</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">pulse_shape</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;rz&#39;</span><span class="p">,</span> <span class="s1">&#39;RZ&#39;</span><span class="p">]:</span>
        <span class="n">rz_pulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sps</span><span class="p">)</span>
        <span class="n">rz_pulse</span><span class="p">[:</span><span class="n">sps</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">rz_pulse</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">())</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sps</span><span class="p">))</span> <span class="o">*</span> <span class="n">mask</span>
    
    <span class="k">elif</span> <span class="n">pulse_shape</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="s1">&#39;GAUSSIAN&#39;</span><span class="p">]:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="n">sps</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The parameter `c` must be a scalar value.&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The parameter `m` must be an integer value.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The parameter `m` must be a positive integer value.&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The parameter `T` must be an integer value.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">sps</span> <span class="ow">or</span> <span class="n">T</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The parameter `T` must be in the range [0, 2*sps].&#39;</span><span class="p">)</span>

        <span class="n">p</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">T</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">))</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">sps</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">sps</span><span class="p">,</span> <span class="mi">8</span><span class="o">*</span><span class="n">sps</span><span class="p">)</span> <span class="c1"># time vector of the Gaussian pulse</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">))</span> <span class="c1"># scaling factor between the width of a slot and the standard deviation of a Gaussian pulse</span>
        <span class="n">pulse</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">T</span><span class="o">/</span><span class="n">k</span><span class="p">)</span> <span class="c1"># gaussian pulse</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span><span class="o">*</span><span class="n">sps</span><span class="p">)</span>
        <span class="n">s</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">sps</span><span class="o">//</span><span class="mi">2</span><span class="p">)::</span><span class="n">sps</span><span class="p">]</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">data</span>
        <span class="n">s</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">sps</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)::</span><span class="n">sps</span><span class="p">]</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">data</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pulse</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The parameter `pulse_shape` must be one of the following values (&quot;rect&quot;, &quot;gaussian&quot;)&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Vout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Vout</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The parameter `Vout` must be a scalar value.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Vout</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">48</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The parameter `Vout` must be in the range [-48, 48] Volts.&#39;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">Vout</span>

    <span class="k">if</span> <span class="n">bias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bias</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The parameter `bias` must be a scalar value.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">bias</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">48</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The parameter `bias` must be in the range [-48, 48] Volts.&#39;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">bias</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">electrical_signal</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">output</span><span class="o">.</span><span class="n">execution_time</span> <span class="o">+=</span> <span class="n">toc</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">BW</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t_</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">execution_time</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">LPF</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">BW</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">execution_time</span> <span class="o">+=</span> <span class="n">t_</span>

    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="PM">
<a class="viewcode-back" href="../../devices.html#opticomlib.devices.PM">[docs]</a>
<span class="k">def</span> <span class="nf">PM</span><span class="p">(</span><span class="n">op_input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> 
       <span class="n">el_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">],</span> 
       <span class="n">Vpi</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">5.0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    **Optical Phase Modulator**</span>

<span class="sd">    Modulate the phase of the input optical signal through input electrical signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op_input : :obj:`optical_signal`</span>
<span class="sd">        Optical signal to be modulated.</span>
<span class="sd">    el_input : :obj:`float`, :obj:`ndarray`, or :obj:`electrical_signal`</span>
<span class="sd">        Driver voltage. It can be an integer value, in which case the phase modulation is constant, or an electrical signal of the same length as the optical signal.</span>
<span class="sd">    Vpi : :obj:`float`</span>
<span class="sd">        Voltage at which the device achieves a phase shift of :math:`\pi`. Default value is 5.0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    op_output: :obj:`optical_signal`</span>
<span class="sd">        Modulated optical signal.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If ``op_input`` type is not [:obj:`optical_signal`].</span>
<span class="sd">        If ``el_input`` type is not in [:obj:`float`, :obj:`ndarray`, :obj:`electrical_signal`].</span>
<span class="sd">    ValueError</span>
<span class="sd">        If ``el_input`` is [:obj:`ndarray`] or [:obj:`electrical_signal`] but, length is not equal to ``op_input`` length.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The output signal is given by:</span>

<span class="sd">    .. figure:: _images/PMv2.png</span>
<span class="sd">        :width: 50%</span>
<span class="sd">        :align: center</span>
<span class="sd">        :alt: MZM</span>
<span class="sd">    </span>
<span class="sd">    .. math:: E_{out} = E_{in} \cdot e^{\left(j\pi \frac{u(t)}{V_{\pi}}\right)}</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. code-block:: python</span>
<span class="sd">        :linenos:</span>

<span class="sd">        from opticomlib.devices import PM</span>
<span class="sd">        from opticomlib import optical_signal, gv</span>
<span class="sd">        import matplotlib.pyplot as plt</span>
<span class="sd">        import numpy as np</span>

<span class="sd">        gv(sps=16, R=1e9) # set samples per bit and bitrate</span>

<span class="sd">        op_input = optical_signal(np.exp(1j*np.linspace(0,4*np.pi, 1000))) # input optical signal ( exp(j*w*t) )</span>
<span class="sd">        t = op_input.t()*1e9</span>

<span class="sd">        fig, axs = plt.subplots(3,1, sharex=True, tight_layout=True)</span>

<span class="sd">        # Constant phase</span>
<span class="sd">        output = PM(op_input, el_input=2.5, Vpi=5)</span>

<span class="sd">        axs[0].set_title(r&#39;Constant phase change ($\Delta f=0$)&#39;)</span>
<span class="sd">        axs[0].plot(t, op_input.signal[0].real, &#39;r-&#39;, label=&#39;input&#39;, lw=3)</span>
<span class="sd">        axs[0].plot(t, output.signal[0].real, &#39;b-&#39;, label=&#39;output&#39;, lw=3)</span>
<span class="sd">        axs[0].grid()</span>

<span class="sd">        # Lineal phase</span>
<span class="sd">        output = PM(op_input, el_input=np.linspace(0,5*np.pi,op_input.len()), Vpi=5)</span>

<span class="sd">        axs[1].set_title(r&#39;Linear phase change  ($\Delta f \rightarrow cte.$)&#39;)</span>
<span class="sd">        axs[1].plot(t, op_input.signal[0].real, &#39;r-&#39;, label=&#39;input&#39;, lw=3)</span>
<span class="sd">        axs[1].plot(t, output.signal[0].real, &#39;b-&#39;, label=&#39;output&#39;, lw=3)</span>
<span class="sd">        axs[1].grid()</span>

<span class="sd">        # Quadratic phase</span>
<span class="sd">        output = PM(op_input, el_input=np.linspace(0,(5*np.pi)**0.5,op_input.len())**2, Vpi=5)</span>

<span class="sd">        plt.title(r&#39;Quadratic phase change ($\Delta f \rightarrow linear$)&#39;)</span>
<span class="sd">        axs[2].plot(t, op_input.signal[0].real, &#39;r-&#39;, label=&#39;input&#39;, lw=3)</span>
<span class="sd">        axs[2].plot(t, output.signal[0].real, &#39;b-&#39;, label=&#39;output&#39;, lw=3)</span>
<span class="sd">        axs[2].grid()</span>

<span class="sd">        plt.xlabel(&#39;Tiempo [ns]&#39;)</span>
<span class="sd">        plt.legend(bbox_to_anchor=(1, 1), loc=&#39;upper left&#39;)</span>
<span class="sd">        plt.show()</span>
<span class="sd">    </span>
<span class="sd">    .. image:: _images/PM_example1.svg</span>
<span class="sd">        :width: 100%</span>
<span class="sd">        :align: center</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op_input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`op_input` must be of type (optical_signal).&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el_input</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="n">el_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">op_input</span><span class="o">.</span><span class="n">len</span><span class="p">())</span> <span class="o">*</span> <span class="n">el_input</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el_input</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">):</span>
        <span class="n">el_input</span> <span class="o">=</span> <span class="n">el_input</span><span class="o">.</span><span class="n">signal</span>
        <span class="k">if</span> <span class="n">el_input</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">op_input</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">len</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The length of `el_input` must be equal to the length of `op_input`.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el_input</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">el_input</span><span class="p">)</span> <span class="o">!=</span> <span class="n">op_input</span><span class="o">.</span><span class="n">len</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The length of `el_input` must be equal to the length of `op_input`.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`el_input` must be of type (int or electrical_signal).&quot;</span><span class="p">)</span>
    
    <span class="n">output</span> <span class="o">=</span> <span class="n">optical_signal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">op_input</span><span class="o">.</span><span class="n">signal</span><span class="p">))</span>

    <span class="n">output</span><span class="o">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">op_input</span><span class="o">.</span><span class="n">signal</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">el_input</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="n">Vpi</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">op_input</span><span class="o">.</span><span class="n">noise</span><span class="p">):</span>
        <span class="n">output</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">op_input</span><span class="o">.</span><span class="n">noise</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">el_input</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="n">Vpi</span><span class="p">)</span>
    
    <span class="n">output</span><span class="o">.</span><span class="n">execution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="MZM">
<a class="viewcode-back" href="../../devices.html#opticomlib.devices.MZM">[docs]</a>
<span class="k">def</span> <span class="nf">MZM</span><span class="p">(</span><span class="n">op_input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> 
        <span class="n">el_input</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">electrical_signal</span><span class="p">,</span> 
        <span class="n">bias</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> 
        <span class="n">Vpi</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> 
        <span class="n">loss_dB</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> 
        <span class="n">ER_dB</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">26.0</span><span class="p">,</span>
        <span class="n">pol</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
        <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    **Mach-Zehnder modulator**</span>

<span class="sd">    Asymmetric coupler and opposite driving voltages model (:math:`u_1(t)=-u_2(t)=u(t)` Push-Pull configuration). </span>
<span class="sd">    The input and output are polarization maintained. Internally, the modulator can select the polarization </span>
<span class="sd">    to be modulated by setting the parameter ``pol`` to ``&#39;x&#39;`` or ``&#39;y&#39;``. If one of them is selected, the other is</span>
<span class="sd">    strongly attenuated (set to zeros).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op_input : :obj:`optical_signal`</span>
<span class="sd">        Optical signal to be modulated. This optical signal must contain only one polarization ``op_input.n_pol=1``. Otherwise </span>
<span class="sd">        it remove the second polarization.</span>
<span class="sd">    el_input : Number, :obj:`ndarray`, or :obj:`electrical_signal`</span>
<span class="sd">        Driver voltage, with zero bias. </span>
<span class="sd">    bias : :obj:`float`, optional</span>
<span class="sd">        Modulator bias voltage. Default is 0.0.</span>
<span class="sd">    Vpi : :obj:`float`, optional</span>
<span class="sd">        Voltage at which the device switches from on-state to off-state. Default is 5.0 V.</span>
<span class="sd">    loss_dB : :obj:`float`, optional</span>
<span class="sd">        Propagation or insertion losses in the modulator, value in dB. Default is 0.0 dB.</span>
<span class="sd">    ER_dB: :obj:`float`, optional</span>
<span class="sd">        Extinction ratio of the modulator, in dB. Default is 26 dB.</span>
<span class="sd">    pol : :obj:`str`, {&#39;x&#39;, &#39;y&#39;} optional</span>
<span class="sd">        Polarization of the modulator. Default is ``&#39;x&#39;``.</span>
<span class="sd">    BW : :obj:`float`, optional</span>
<span class="sd">        Modulator bandwidth in Hz. If not provided, the bandwidth is not limited.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :obj:`optical_signal`</span>
<span class="sd">        Modulated optical signal.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If ``op_input`` type is not [:obj:`optical_signal`].</span>
<span class="sd">        If ``el_input`` type is not in [:obj:`float`, :obj:`ndarray`, :obj:`electrical_signal`].</span>
<span class="sd">    ValueError</span>
<span class="sd">        If ``el_input`` is [:obj:`ndarray`] or [:obj:`electrical_signal`] but, length is not equal to ``op_input`` length.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. figure:: _images/MZMv2.png</span>
<span class="sd">        :width: 50%</span>
<span class="sd">        :align: center</span>
<span class="sd">        :alt: MZM</span>

<span class="sd">    The output signal is given by [1]_:</span>


<span class="sd">    .. math:: </span>
<span class="sd">        \vec{E}_{out} = \vec{E}_{in} \cdot \sqrt{l} \cdot \left[ \cos\left(\frac{\pi}{2V_{\pi}}(u(t)+V_{bias})\right) + j \frac{\eta}{2} \sin\left(\frac{\pi}{2V_{\pi}}(u(t)+V_{bias})\right) \right] </span>

<span class="sd">    where :math:`\eta = 2\times 10^{-ER_{dB}/10}` and :math:`l = 10^{-loss_{dB}/10}`. </span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Tetsuya Kawanishi, &quot;Electro-optic Modulation for Photonic Networks&quot;, Chapter 4.3 (2022). doi: https://doi.org/10.1007/978-3-030-86720-1</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. code-block:: python</span>
<span class="sd">        :linenos:</span>

<span class="sd">        from opticomlib import idbm, dbm, optical_signal, gv</span>
<span class="sd">        from opticomlib.devices import MZM</span>

<span class="sd">        import numpy as np</span>
<span class="sd">        import matplotlib.pyplot as plt</span>

<span class="sd">        gv(sps=128, R=10e9) # set samples per bit and bitrate</span>

<span class="sd">        Vpi = 5</span>
<span class="sd">        tx_seq = np.array([0, 1, 0, 1, 0, 0, 1, 1, 0, 0], bool)</span>

<span class="sd">        V = DAC(~tx_seq, Vout=Vpi, pulse_shape=&#39;rect&#39;) - Vpi/2 </span>

<span class="sd">        input = optical_signal( np.ones_like(V.signal)*idbm(10)**0.5 )</span>
<span class="sd">        input.noise = np.random.normal(0, 0.01, input.len())</span>
<span class="sd">        t = input.t()*1e9</span>

<span class="sd">        mod_sig = MZM(input, el_input=V, bias=Vpi/2, Vpi=Vpi, loss_dB=2, ER_dB=40, BW=40e9)</span>

<span class="sd">        fig, axs = plt.subplots(3,1, sharex=True, tight_layout=True)</span>


<span class="sd">        # Plot input and output power</span>
<span class="sd">        axs[0].plot(t, dbm(input.abs()**2), &#39;r-&#39;, label=&#39;input&#39;, lw=3)</span>
<span class="sd">        axs[0].plot(t, dbm(mod_sig.abs()**2), &#39;C1-&#39;, label=&#39;output&#39;, lw=3)</span>
<span class="sd">        axs[0].legend(bbox_to_anchor=(1, 1), loc=&#39;upper left&#39;)</span>
<span class="sd">        axs[0].set_ylabel(&#39;Potencia [dBm]&#39;)</span>
<span class="sd">        for i in t[::gv.sps]:</span>
<span class="sd">            axs[0].axvline(i, color=&#39;k&#39;, linestyle=&#39;--&#39;, alpha=0.5)</span>

<span class="sd">        # # Plot fase</span>
<span class="sd">        phi_in = input.phase()</span>
<span class="sd">        phi_out = mod_sig.phase()</span>

<span class="sd">        axs[1].plot(t, phi_in, &#39;b-&#39;, label=&#39;Fase in&#39;, lw=3)</span>
<span class="sd">        axs[1].plot(t, phi_out, &#39;C0-&#39;, label=&#39;Fase out&#39;, lw=3)</span>
<span class="sd">        axs[1].set_ylabel(&#39;Fase [rad]&#39;)</span>
<span class="sd">        axs[1].legend(bbox_to_anchor=(1, 1), loc=&#39;upper left&#39;)</span>
<span class="sd">        for i in t[::gv.sps]:</span>
<span class="sd">            axs[1].axvline(i, color=&#39;k&#39;, linestyle=&#39;--&#39;, alpha=0.5)</span>

<span class="sd">        # Frecuency chirp</span>
<span class="sd">        freq_in = 1/2/np.pi*np.diff(phi_in)/np.diff(t)</span>
<span class="sd">        freq_out = 1/2/np.pi*np.diff(phi_out)/np.diff(t)</span>

<span class="sd">        axs[2].plot(t[:-1], freq_in, &#39;k&#39;, label=&#39;Frequency in&#39;, lw=3)</span>
<span class="sd">        axs[2].plot(t[:-1], freq_out, &#39;C7&#39;, label=&#39;Frequency out&#39;, lw=3)</span>
<span class="sd">        axs[2].set_xlabel(&#39;Tiempo [ns]&#39;)</span>
<span class="sd">        axs[2].set_ylabel(&#39;Frequency Chirp [Hz]&#39;)</span>
<span class="sd">        axs[2].legend(bbox_to_anchor=(1, 1), loc=&#39;upper left&#39;)</span>
<span class="sd">        for i in t[::gv.sps]:</span>
<span class="sd">            axs[2].axvline(i, color=&#39;k&#39;, linestyle=&#39;--&#39;, alpha=0.5)</span>
<span class="sd">        plt.show()</span>

<span class="sd">    .. image:: _images/MZM_example.svg</span>
<span class="sd">        :width: 100%</span>
<span class="sd">        :align: center</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tic</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op_input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span> 
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`op_input` must be of type (optical_signal).&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el_input</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">):</span>
        <span class="n">el_input</span> <span class="o">=</span> <span class="n">electrical_signal</span><span class="p">(</span><span class="n">el_input</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">op_input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span> <span class="o">!=</span> <span class="n">el_input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span> <span class="ow">and</span> <span class="n">el_input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length of `op_input` and `el_input` must be equal or `el_input` must be an scalar value. Current lengths are </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op_input</span><span class="o">.</span><span class="n">len</span><span class="p">(),</span> <span class="n">el_input</span><span class="o">.</span><span class="n">len</span><span class="p">()))</span>

    <span class="k">if</span> <span class="n">pol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The parameter `pol` must be one of the following values (&#39;x&#39;, &#39;y&#39;).&quot;</span><span class="p">)</span>

    <span class="n">loss</span> <span class="o">=</span> <span class="n">idb</span><span class="p">(</span><span class="o">-</span><span class="n">loss_dB</span><span class="p">)</span> <span class="c1"># Propagation losses</span>
    <span class="n">eta</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">idb</span><span class="p">(</span><span class="o">-</span><span class="n">ER_dB</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="c1"># armsdesvalance factor</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">op_input</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="n">g_t</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">Vpi</span> <span class="o">*</span> <span class="p">(</span><span class="n">el_input</span><span class="o">.</span><span class="n">signal</span> <span class="o">+</span> <span class="n">bias</span><span class="p">)</span>
    <span class="n">h_t</span> <span class="o">=</span> <span class="n">loss</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">g_t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">eta</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">g_t</span><span class="p">))</span>
    
    <span class="n">output</span><span class="o">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">signal</span> <span class="o">*</span> <span class="n">h_t</span>
    <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">noise</span> <span class="o">*</span> <span class="n">h_t</span>
    
    <span class="k">if</span> <span class="n">pol</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span> <span class="ow">and</span> <span class="n">output</span><span class="o">.</span><span class="n">n_pol</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">output</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">pol</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span> <span class="ow">and</span> <span class="n">output</span><span class="o">.</span><span class="n">n_pol</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">output</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">t_</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="n">output</span><span class="o">.</span><span class="n">execution_time</span> <span class="o">+=</span> <span class="n">t_</span> 
    
    <span class="k">if</span> <span class="n">BW</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">BPF</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">BW</span><span class="p">)</span> <span class="c1"># Filter the modulated optical signal and add the execution time of the filter</span>
        
    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="BPF">
<a class="viewcode-back" href="../../devices.html#opticomlib.devices.BPF">[docs]</a>
<span class="k">def</span> <span class="nf">BPF</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> 
        <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    **Optical Band-Pass Filter**</span>

<span class="sd">    Filters the input optical signal, allowing only the desired frequency band to pass.</span>
<span class="sd">    Bessel filter model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : optical_signal</span>
<span class="sd">        The optical signal to be filtered.</span>
<span class="sd">    BW : float</span>
<span class="sd">        The bandwidth of the filter in Hz.</span>
<span class="sd">    n : int, default: 4</span>
<span class="sd">        The order of the filter.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    optical_signal</span>
<span class="sd">        The filtered optical signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`input` must be of type (optical_signal).&quot;</span><span class="p">)</span>

    <span class="n">sos_band</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">bessel</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">Wn</span><span class="o">=</span><span class="n">BW</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">gv</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;sos&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">output</span><span class="o">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos_band</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos_band</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">output</span><span class="o">.</span><span class="n">execution_time</span> <span class="o">+=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="EDFA">
<a class="viewcode-back" href="../../devices.html#opticomlib.devices.EDFA">[docs]</a>
<span class="k">def</span> <span class="nf">EDFA</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> 
         <span class="n">G</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
         <span class="n">NF</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
         <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    **Erbium Doped Fiber**</span>

<span class="sd">    Amplifies the optical signal at the input, adding amplified spontaneous emission (ASE) noise. </span>
<span class="sd">    Simplest model (no saturation output power).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : optical_signal</span>
<span class="sd">        The optical signal to be amplified.</span>
<span class="sd">    G : float</span>
<span class="sd">        The gain of the amplifier, in dB.</span>
<span class="sd">    NF : float</span>
<span class="sd">        The noise figure of the amplifier, in dB.</span>
<span class="sd">    BW : float</span>
<span class="sd">        The bandwidth of the amplifier, in Hz.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    optical_signal</span>
<span class="sd">        The amplified optical signal.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If ``input`` is not an optical_signal.    </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`input` must be of type (optical_signal).&quot;</span><span class="p">)</span>
     
    <span class="n">output</span> <span class="o">=</span> <span class="n">BPF</span><span class="p">(</span> <span class="nb">input</span> <span class="o">*</span> <span class="n">idb</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">BW</span> <span class="p">)</span>
    <span class="c1"># ase = BPF( optical_signal( np.zeros_like(input.signal), np.exp(-1j*np.random.uniform(0, 2*pi, input.noise.shape)) ), BW )</span>
    <span class="n">ase</span> <span class="o">=</span> <span class="n">BPF</span><span class="p">(</span> <span class="n">optical_signal</span><span class="p">(</span> <span class="n">noise</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span> <span class="p">),</span> <span class="n">BW</span> <span class="p">)</span>
    <span class="n">t_</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">execution_time</span> <span class="o">+</span> <span class="n">ase</span><span class="o">.</span><span class="n">execution_time</span>
    
    <span class="n">tic</span><span class="p">()</span>
    <span class="n">P_ase</span> <span class="o">=</span> <span class="n">idb</span><span class="p">(</span><span class="n">NF</span><span class="p">)</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="n">gv</span><span class="o">.</span><span class="n">f0</span> <span class="o">*</span> <span class="p">(</span><span class="n">idb</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">BW</span>

    <span class="n">norm_x</span><span class="p">,</span> <span class="n">norm_y</span> <span class="o">=</span> <span class="n">ase</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="s1">&#39;noise&#39;</span><span class="p">)</span> <span class="c1"># power of ASE noise in [W] for each polarization</span>

    <span class="n">ase</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">norm_x</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">/</span> <span class="p">(</span><span class="n">P_ase</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">ase</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">norm_y</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">/</span> <span class="p">(</span><span class="n">P_ase</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>

    <span class="n">output</span> <span class="o">+=</span> <span class="n">ase</span>

    <span class="n">output</span><span class="o">.</span><span class="n">execution_time</span> <span class="o">=</span> <span class="n">t_</span> <span class="o">+</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="DM">
<a class="viewcode-back" href="../../devices.html#opticomlib.devices.DM">[docs]</a>
<span class="k">def</span> <span class="nf">DM</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> <span class="n">D</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">retH</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    **Dispersive Medium**</span>

<span class="sd">    Emulates a medium with only the dispersion property, i.e., only :math:`\beta_2` different from zero.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : optical_signal</span>
<span class="sd">        The input optical signal.</span>
<span class="sd">    D : float</span>
<span class="sd">        The dispersion coefficient of the medium (:math:`\beta_2z`), in [ps^2].</span>
<span class="sd">    retH : bool, default: False</span>
<span class="sd">        If True, the frequency response of the medium is also returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    optical_signal</span>
<span class="sd">        The output optical signal.</span>
<span class="sd">    H : ndarray</span>
<span class="sd">        The frequency response of the medium. If ``retH=True``.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If ``input`` is not an optical signal.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Frequency response of the medium is given by:</span>

<span class="sd">    .. math:: H(\omega) = e^{-j \frac{D}{2} \omega^2}</span>

<span class="sd">    The output signal is simply a fase modulation in the frequency domain of the input signal:</span>

<span class="sd">    .. math :: E_{out}(t) = \mathcal{F}^{-1} \left\{ H(\omega) \cdot \mathcal{F} \left\{ E_{in}(t) \right\} \right\}</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    .. plot::</span>
<span class="sd">        :include-source:</span>
<span class="sd">        :alt: DM example 1</span>
<span class="sd">        :align: center</span>

<span class="sd">        from opticomlib.devices import DM, DAC</span>
<span class="sd">        from opticomlib import optical_signal, gv, idbm, bode </span>

<span class="sd">        import matplotlib.pyplot as plt</span>
<span class="sd">        import numpy as np</span>

<span class="sd">        gv(N=7, sps=32, R=10e9)</span>

<span class="sd">        signal = DAC(&#39;0,0,0,1,0,0,0&#39;, pulse_shape=&#39;gaussian&#39;)</span>
<span class="sd">        input = optical_signal( signal.signal/signal.power()**0.5*idbm(20)**0.5, n_pol=2 )</span>

<span class="sd">        output, H = DM(input, D=4000, retH=True)</span>

<span class="sd">        t = gv.t*1e9</span>

<span class="sd">        plt.style.use(&#39;dark_background&#39;)</span>
<span class="sd">        fig, ax = plt.subplots(2, 1, sharex=True, gridspec_kw={&#39;hspace&#39;: 0.05})</span>
<span class="sd">        </span>
<span class="sd">        ax[0].plot(t, input.abs()[0], &#39;r-&#39;, lw=3, label=&#39;input&#39;)</span>
<span class="sd">        ax[0].plot(t, output.abs()[0], &#39;b-&#39;, lw=3, label=&#39;output&#39;)</span>

<span class="sd">        ax[0].set_ylabel(r&#39;$|E(t)|$&#39;)</span>

<span class="sd">        ax[1].plot(t[:-1], np.diff(input.phase()[0])/gv.dt*1e-9, &#39;r-&#39;, lw=3)</span>
<span class="sd">        ax[1].plot(t[:-1], np.diff(output.phase()[0])/gv.dt*1e-9, &#39;b-&#39;, lw=3)</span>

<span class="sd">        plt.xlabel(&#39;Time (ns)&#39;)</span>
<span class="sd">        plt.ylabel(r&#39;$f_i(t)$ (GHz)&#39;)</span>
<span class="sd">        plt.ylim(-150, 150)</span>
<span class="sd">        plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The input must be an optical signal!&quot;</span><span class="p">)</span> 

    <span class="c1"># Convert units of D:</span>
    <span class="n">D</span> <span class="o">*=</span> <span class="mf">1e-12</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="nb">input</span><span class="o">.</span><span class="n">w</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="o">/</span><span class="mi">2</span> <span class="p">)</span>
    
    <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">H</span><span class="p">)(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
    
    <span class="n">output</span><span class="o">.</span><span class="n">execution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">retH</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="nb">input</span><span class="o">.</span><span class="n">w</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">D</span><span class="o">/</span><span class="mi">2</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="FIBER">
<a class="viewcode-back" href="../../devices.html#opticomlib.devices.FIBER">[docs]</a>
<span class="k">def</span> <span class="nf">FIBER</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> 
          <span class="n">length</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
          <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> 
          <span class="n">beta_2</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> 
          <span class="n">beta_3</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> 
          <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> 
          <span class="n">phi_max</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> 
          <span class="n">show_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    **Optical Fiber**</span>

<span class="sd">    Simulates the transmission through an optical fiber, solving Schrdinger&#39;s equation numerically,</span>
<span class="sd">    by using split-step Fourier method with adaptive step (method based on limiting the nonlinear phase rotation) [#first]_. </span>
<span class="sd">    Polarization mode dispersion (PMD) is not considered in this model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : optical_signal</span>
<span class="sd">        Input optical signal.</span>
<span class="sd">    length : float</span>
<span class="sd">        Length of the fiber, in [km].</span>
<span class="sd">    alpha : float, default: 0.0</span>
<span class="sd">        Attenuation coefficient of the fiber, in [dB/km].</span>
<span class="sd">    beta_2 : float, default: 0.0</span>
<span class="sd">        Second-order dispersion coefficient of the fiber, in [ps^2/km].</span>
<span class="sd">    beta_3 : float, default: 0.0</span>
<span class="sd">        Third-order dispersion coefficient of the fiber, in [ps^3/km].</span>
<span class="sd">    gamma : float, default: 0.0</span>
<span class="sd">        Nonlinearity coefficient of the fiber, in [(Wkm)^-1].</span>
<span class="sd">    phi_max : float, default: 0.05</span>
<span class="sd">        Upper bound of the nonlinear phase rotation, in [rad].</span>
<span class="sd">    show_progress : bool, default: False</span>
<span class="sd">        Show algorithm progress bar.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    optical_signal</span>
<span class="sd">        Output optical signal.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If ``input`` is not an optical signal.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [#] O.V. Sinkin; R. Holzlohner; J. Zweck; C.R. Menyuk, &quot;Optimization of the split-step Fourier method in modeling optical-fiber communications systems,&quot; vol. 21, no. 1, pp. 61-68, Jan. 2003, doi: https://doi.org/10.1109/JLT.2003.808628</span>
<span class="sd">    </span>
<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    .. plot:: </span>
<span class="sd">        :include-source:</span>
<span class="sd">        :alt: FIBER example 1</span>
<span class="sd">        :align: center</span>
<span class="sd">        :caption: The input signal is a 10 Gbps NRZ signal with 20 dBm of power. The fiber has a length of 50 km, an attenuation of 0.01 dB/km, </span>
<span class="sd">                    a second-order dispersion of -20 ps^2/km, and a nonlinearity coefficient of 0.1 (Wkm)^-1. The output signal is shown in blue.</span>

<span class="sd">        from opticomlib.devices import FIBER, DAC</span>
<span class="sd">        from opticomlib import optical_signal, gv, idbm</span>

<span class="sd">        gv(sps=32, R=10e9)</span>

<span class="sd">        signal = DAC(&#39;0,0,0,1,0,0,0&#39;, pulse_shape=&#39;gaussian&#39;)</span>
<span class="sd">        input = optical_signal( signal.signal/signal.power()**0.5*idbm(20)**0.5, n_pol=2)</span>

<span class="sd">        output = FIBER(input, length=50, alpha=0.01, beta_2=-20, gamma=0.1, show_progress=True)</span>

<span class="sd">        input.plot(&#39;r-&#39;, label=&#39;input&#39;, lw=3)</span>
<span class="sd">        output.plot(&#39;b-&#39;, label=&#39;output&#39;, lw=3).show()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tic</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`input` must be of type (optical_signal).&quot;</span><span class="p">)</span>

    <span class="n">alpha</span>  <span class="o">=</span> <span class="n">alpha</span><span class="o">/</span><span class="mf">4.343</span> <span class="c1"># [1/km]</span>

    <span class="n">w</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">w</span><span class="p">()</span><span class="o">*</span><span class="mf">1e-12</span> <span class="c1"># [rad/ps]</span>
    <span class="n">D_op</span> <span class="o">=</span> <span class="o">-</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">beta_2</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">6</span> <span class="o">*</span> <span class="n">beta_3</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">3</span>

    <span class="n">A</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="k">if</span> <span class="p">(</span><span class="n">beta_2</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">beta_3</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">gamma</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="n">phi_max</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="n">x_length</span> <span class="o">=</span> <span class="n">h</span>

    <span class="k">if</span> <span class="n">show_progress</span><span class="p">:</span>
        <span class="n">barra_progreso</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">exp_NL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D_op</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span> <span class="n">exp_L</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span> <span class="c1"># Symmetric Split-Step Fourier Method </span>

        <span class="k">if</span> <span class="n">show_progress</span><span class="p">:</span>
            <span class="n">barra_progreso</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">h</span> <span class="o">/</span> <span class="n">length</span> <span class="p">)</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">phi_max</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">if</span> <span class="n">gamma</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">length</span> 

        <span class="k">if</span> <span class="n">x_length</span> <span class="o">+</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">x_length</span> <span class="o">+=</span> <span class="n">h</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">x_length</span>
    
    <span class="k">if</span> <span class="n">h</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">exp_NL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D_op</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span> <span class="n">exp_L</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">show_progress</span><span class="p">:</span>
            <span class="n">barra_progreso</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">h</span> <span class="o">/</span> <span class="n">length</span> <span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">optical_signal</span><span class="p">(</span> <span class="n">A</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">noise</span> <span class="p">)</span>
    <span class="n">output</span><span class="o">.</span><span class="n">execution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="LPF">
<a class="viewcode-back" href="../../devices.html#opticomlib.devices.LPF">[docs]</a>
<span class="k">def</span> <span class="nf">LPF</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">],</span> 
        <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> 
        <span class="n">fs</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">retH</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    **Low Pass Filter**</span>

<span class="sd">    Filters the input electrical signal, allowing only the desired frequency band to pass.</span>
<span class="sd">    Bessel filter model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : ndarray or electrical_signal</span>
<span class="sd">        Electrical signal to be filtered.</span>
<span class="sd">    BW : float</span>
<span class="sd">        Filter bandwidth or cutoff frequency, in [Hz].</span>
<span class="sd">    n : int, default: 4</span>
<span class="sd">        Filter order.</span>
<span class="sd">    fs : float, default: gv.fs</span>
<span class="sd">        Sampling frequency of the input signal.</span>
<span class="sd">    retH : bool, default: False</span>
<span class="sd">        If True, the frequency response of the filter is also returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    electrical_signal</span>
<span class="sd">        Filtered electrical signal.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If ``input`` is not of type ndarray or electrical_signal.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    .. plot::</span>
<span class="sd">        :include-source:</span>
<span class="sd">        :alt: LPF example 1</span>
<span class="sd">        :align: center</span>
<span class="sd">        </span>
<span class="sd">        from opticomlib.devices import LPF</span>
<span class="sd">        from opticomlib import gv, electrical_signal</span>
<span class="sd">        import matplotlib.pyplot as plt</span>
<span class="sd">        import numpy as np</span>

<span class="sd">        gv(N = 10, sps=128, R=1e9)</span>

<span class="sd">        t = gv.t</span>
<span class="sd">        c = 20e9/t[-1]   # frequency chirp from 0 to 20 GHz</span>

<span class="sd">        input = electrical_signal( np.sin( np.pi*c*t**2) )</span>
<span class="sd">        output = LPF(input, 10e9)</span>

<span class="sd">        input.psd(&#39;r&#39;, label=&#39;input&#39;, lw=2)</span>
<span class="sd">        output.psd(&#39;b&#39;, label=&#39;output&#39;, lw=2)</span>

<span class="sd">        plt.xlim(-30,30)</span>
<span class="sd">        plt.ylim(-20, 5)</span>
<span class="sd">        plt.annotate(&#39;-6 dB&#39;, xy=(10, -5), xytext=(10, 2), c=&#39;r&#39;, arrowprops=dict(arrowstyle=&#39;&lt;-&gt;&#39;), fontsize=12, ha=&#39;center&#39;, va=&#39;center&#39;)</span>
<span class="sd">        plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`input` must be of type (ndarray or electrical_signal).&quot;</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">):</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span>
            <span class="n">noise</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">noise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="nb">input</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">fs</span><span class="p">:</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">fs</span>

    <span class="n">sos_band</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">bessel</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="n">n</span><span class="p">,</span> <span class="n">Wn</span> <span class="o">=</span> <span class="n">BW</span><span class="p">,</span> <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;sos&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">electrical_signal</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">output</span><span class="o">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos_band</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">noise</span><span class="p">):</span>
        <span class="n">output</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos_band</span><span class="p">,</span> <span class="n">noise</span><span class="p">)</span>
    
    <span class="n">output</span><span class="o">.</span><span class="n">execution_time</span> <span class="o">+=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">retH</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span><span class="n">H</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfreqz</span><span class="p">(</span><span class="n">sos_band</span><span class="p">,</span> <span class="n">worN</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">whole</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="PD">
<a class="viewcode-back" href="../../devices.html#opticomlib.devices.PD">[docs]</a>
<span class="k">def</span> <span class="nf">PD</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> 
       <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> 
       <span class="n">responsivity</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> 
       <span class="n">T</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">300.0</span><span class="p">,</span> 
       <span class="n">R_load</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">50.0</span><span class="p">,</span> 
       <span class="n">noise</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;ase-only&#39;</span><span class="p">,</span><span class="s1">&#39;thermal-only&#39;</span><span class="p">,</span><span class="s1">&#39;shot-only&#39;</span><span class="p">,</span><span class="s1">&#39;ase-thermal&#39;</span><span class="p">,</span><span class="s1">&#39;ase-shot&#39;</span><span class="p">,</span><span class="s1">&#39;thermal-shot&#39;</span><span class="p">,</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    **Photodetector**</span>

<span class="sd">    Simulates the detection of an optical signal by a photodetector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : optical_signal</span>
<span class="sd">        Optical signal to be detected.</span>
<span class="sd">    BW : float</span>
<span class="sd">        Detector bandwidth in [Hz].</span>
<span class="sd">    responsivity : float, default: 1.0</span>
<span class="sd">        Detector responsivity in [A/W].</span>
<span class="sd">    T : float, default: 300.0</span>
<span class="sd">        Detector temperature in [K].</span>
<span class="sd">    R_load : float, default: 50.0</span>
<span class="sd">        Detector load resistance in [:math:`\Omega`].</span>
<span class="sd">    noise : str, default: &#39;all&#39;</span>
<span class="sd">        Type of noise to include in the simulation.</span>
<span class="sd">        Options include:</span>
<span class="sd">        </span>
<span class="sd">        - ``&#39;ase-only&#39;``: only include ASE noise</span>
<span class="sd">        - ``&#39;thermal-only&#39;``: only include thermal noise</span>
<span class="sd">        - ``&#39;shot-only&#39;``: only include shot noise</span>
<span class="sd">        - ``&#39;ase-thermal&#39;``: include ASE and thermal noise</span>
<span class="sd">        - ``&#39;ase-shot&#39;``: include ASE and shot noise</span>
<span class="sd">        - ``&#39;thermal-shot&#39;``: include thermal and shot noise</span>
<span class="sd">        - ``&#39;all&#39;``: include all types of noise</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    electrical_signal</span>
<span class="sd">        The detected electrical signal.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If ``input`` is not of type optical_signal.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the ``noise`` argument is not one of the valid options.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`input` must be of type (optical_signal).&#39;</span><span class="p">)</span>

    <span class="n">i_sig</span> <span class="o">=</span> <span class="n">responsivity</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="s1">&#39;signal&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># se suman las dos polarizaciones</span>

    <span class="k">if</span> <span class="s1">&#39;thermal&#39;</span> <span class="ow">in</span> <span class="n">noise</span> <span class="ow">or</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="n">noise</span><span class="p">:</span>
        <span class="n">S_T</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">kB</span> <span class="o">*</span> <span class="n">T</span> <span class="o">*</span> <span class="n">BW</span> <span class="o">/</span> <span class="n">R_load</span> <span class="c1"># Density of thermal noise in [A^2]</span>
        <span class="n">i_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">S_T</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">())</span>
    
    <span class="k">if</span> <span class="s1">&#39;shot&#39;</span> <span class="ow">in</span> <span class="n">noise</span> <span class="ow">or</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="n">noise</span><span class="p">:</span>
        <span class="n">S_N</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">e</span> <span class="o">*</span> <span class="n">i_sig</span> <span class="o">*</span> <span class="n">BW</span> <span class="c1"># Density of shot noise in [A^2]</span>
        <span class="n">i_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="p">))(</span><span class="n">S_N</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;ase&#39;</span> <span class="ow">in</span> <span class="n">noise</span> <span class="ow">or</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="n">noise</span><span class="p">:</span>
        <span class="n">i_sig_sp</span> <span class="o">=</span> <span class="n">responsivity</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">+</span> \
                            <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> \
                            <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">+</span> \
                            <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">i_sp_sp</span> <span class="o">=</span> <span class="n">responsivity</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="s1">&#39;noise&#39;</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># se suman las dos polarizaciones</span>

    <span class="k">if</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;ase-only&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_sig_sp</span>  <span class="o">+</span> <span class="n">i_sp_sp</span>
    <span class="k">elif</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;thermal-only&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_T</span> 
    <span class="k">elif</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;shot-only&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_N</span>
    <span class="k">elif</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;ase-shot&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_sig_sp</span>  <span class="o">+</span> <span class="n">i_sp_sp</span> <span class="o">+</span> <span class="n">i_N</span> 
    <span class="k">elif</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;ase-thermal&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_sig_sp</span>  <span class="o">+</span> <span class="n">i_sp_sp</span> <span class="o">+</span> <span class="n">i_T</span> 
    <span class="k">elif</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;thermal-shot&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_T</span> <span class="o">+</span> <span class="n">i_N</span> 
    <span class="k">elif</span> <span class="n">noise</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">i_sig_sp</span>  <span class="o">+</span> <span class="n">i_sp_sp</span> <span class="o">+</span> <span class="n">i_N</span> <span class="o">+</span> <span class="n">i_T</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The argument `noise` must be one of the following: &#39;ase-only&#39;,&#39;thermal-only&#39;,&#39;shot-only&#39;,&#39;ase-thermal&#39;,&#39;ase-shot&#39;,&#39;thermal-shot&#39;,&#39;all&#39;.&quot;</span><span class="p">)</span>
    
    <span class="n">t_</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="n">filt</span> <span class="o">=</span> <span class="n">LPF</span><span class="p">(</span><span class="n">i_sig</span><span class="p">,</span> <span class="n">BW</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">electrical_signal</span><span class="p">(</span><span class="n">filt</span><span class="o">.</span><span class="n">signal</span><span class="p">,</span> <span class="n">noise</span><span class="p">)</span>

    <span class="n">output</span><span class="o">.</span><span class="n">execution_time</span> <span class="o">=</span> <span class="n">filt</span><span class="o">.</span><span class="n">execution_time</span> <span class="o">+</span> <span class="n">t_</span>
    <span class="k">return</span> <span class="n">output</span></div>




<div class="viewcode-block" id="ADC">
<a class="viewcode-back" href="../../devices.html#opticomlib.devices.ADC">[docs]</a>
<span class="k">def</span> <span class="nf">ADC</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">electrical_signal</span><span class="p">,</span> <span class="n">fs</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">BW</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nbits</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">binary_sequence</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    **Analog-to-Digital Converter**</span>

<span class="sd">    Converts an analog electrical signal into a quantized digital signal, sampled at a frequency `fs`</span>
<span class="sd">    and filtered with a bandwidth BW.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : electrical_signal</span>
<span class="sd">        Electrical signal to be quantized.</span>
<span class="sd">    fs : float, default: None</span>
<span class="sd">        Sampling frequency of the output signal.</span>
<span class="sd">    BW : float, default: None</span>
<span class="sd">        ADC bandwidth in Hz.</span>
<span class="sd">    nbits : int, default: 8</span>
<span class="sd">        Vertical resolution of the ADC, in bits.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    electrical_signal</span>
<span class="sd">        Quantized digital signal.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the ``input`` is not of type `electrical_signal`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`input` debe ser del tipo (electrical_signal).&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">fs</span><span class="p">:</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">fs</span>

    <span class="k">if</span> <span class="n">BW</span><span class="p">:</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">bessel</span><span class="p">(</span><span class="n">N</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">Wn</span> <span class="o">=</span> <span class="n">BW</span><span class="p">,</span> <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="nb">input</span><span class="o">.</span><span class="n">fs</span><span class="p">(),</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;sos&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span><span class="p">)</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">signal</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span>

    <span class="n">signal</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span><span class="o">*</span><span class="n">fs</span><span class="o">/</span><span class="nb">input</span><span class="o">.</span><span class="n">fs</span><span class="p">()))</span>

    <span class="n">V_min</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">V_max</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">dig_signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span> <span class="p">(</span><span class="n">signal</span> <span class="o">-</span> <span class="n">V_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">V_max</span> <span class="o">-</span> <span class="n">V_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="c1"># normalizo la seal entre 0 y 2**nbits-1</span>
    <span class="n">dig_signal</span> <span class="o">=</span> <span class="n">dig_signal</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">V_max</span> <span class="o">-</span> <span class="n">V_min</span><span class="p">)</span> <span class="o">+</span> <span class="n">V_min</span> <span class="c1"># vuelvo a la amplitud original</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">):</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">)</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span><span class="o">*</span><span class="n">fs</span><span class="o">//</span><span class="nb">input</span><span class="o">.</span><span class="n">fs</span><span class="p">()))</span>
        <span class="n">V_min</span> <span class="o">=</span> <span class="n">noise</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">V_max</span> <span class="o">=</span> <span class="n">noise</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">dig_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span> <span class="p">(</span><span class="n">noise</span> <span class="o">-</span> <span class="n">V_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">V_max</span> <span class="o">-</span> <span class="n">V_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="c1"># normalizo la seal entre 0 y 2**nbits-1</span>
        <span class="n">dig_noise</span> <span class="o">=</span> <span class="n">dig_noise</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">nbits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">V_max</span> <span class="o">-</span> <span class="n">V_min</span><span class="p">)</span> <span class="o">+</span> <span class="n">V_min</span> <span class="c1"># vuelvo a la amplitud original</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">electrical_signal</span><span class="p">(</span> <span class="n">dig_signal</span><span class="p">,</span> <span class="n">dig_noise</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">electrical_signal</span><span class="p">(</span> <span class="n">dig_signal</span> <span class="p">)</span>

    <span class="n">output</span><span class="o">.</span><span class="n">execution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="GET_EYE">
<a class="viewcode-back" href="../../devices.html#opticomlib.devices.GET_EYE">[docs]</a>
<span class="k">def</span> <span class="nf">GET_EYE</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">electrical_signal</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">nslots</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span> <span class="n">sps_resamp</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    **Get Eye Parameters Estimator**</span>

<span class="sd">    Estimates all the fundamental parameters and metrics of the eye diagram of the input electrical signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : :obj:`electrical_signal` | :obj:`np.ndarray`</span>
<span class="sd">        Electrical or optical signal from which the eye diagram will be estimated.</span>
<span class="sd">    nslots : :obj:`int`, default: 4096</span>
<span class="sd">        Number of slots to consider for eye reconstruction.</span>
<span class="sd">    sps_resamp : :obj:`int`, default: None</span>
<span class="sd">        Number of samples per slot to interpolate the original signal.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :obj:`eye`</span>
<span class="sd">        Object of the eye class with all the parameters and metrics of the eye diagram.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the ``input`` is a ndarray but dimention is &gt;2.</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the ``input`` is not of type `electrical_signal`, `optical_signal` or `np.ndarray`.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    .. code-block:: python</span>
<span class="sd">        :linenos:</span>

<span class="sd">        from opticomlib.devices import PRBS, DAC, GET_EYE</span>
<span class="sd">        from opticomlib import gv</span>
<span class="sd">        import numpy as np</span>

<span class="sd">        gv(sps=64, R=1e9)</span>

<span class="sd">        y = DAC( PRBS(), pulse_shape=&#39;gaussian&#39;)</span>
<span class="sd">        y.noise = np.random.normal(0, 0.05, y.len())</span>

<span class="sd">        GET_EYE(y, sps_resamp=512).plot() # with interpolation</span>

<span class="sd">    .. image:: /_images/GET_EYE_example1.png</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">shorth_int</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimation of the shortest interval containing 50% of the samples in &#39;data&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : ndarray</span>
<span class="sd">            Array of data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple[float, float]</span>
<span class="sd">            The shortest interval containing 50% of the samples in &#39;data&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">diff_lag</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">data</span><span class="p">,</span><span class="n">lag</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="n">lag</span><span class="p">:]</span><span class="o">-</span><span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="n">lag</span><span class="p">]</span>  <span class="c1"># Difference between two elements of an array separated by a distance &#39;lag&#39;</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">lag</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">diff_lag</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">lag</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span><span class="o">&lt;</span><span class="mf">1e-10</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">lag</span><span class="p">])</span>
    
    <span class="k">def</span> <span class="nf">find_nearest</span><span class="p">(</span><span class="n">levels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span> 
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the element in &#39;levels&#39; that is closest to each value in &#39;data&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        levels : np.ndarray</span>
<span class="sd">            Reference levels.</span>
<span class="sd">        data : Union[np.ndarray, float]</span>
<span class="sd">            Values to compare.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[np.ndarray, float]</span>
<span class="sd">            Vector or float with the values from &#39;levels&#39; corresponding to each value in &#39;data&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">levels</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">levels</span> <span class="o">-</span> <span class="n">data</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">levels</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">levels</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">,(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)]</span>

    <span class="n">eye_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">electrical_signal</span><span class="p">):</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="n">electrical_signal</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
                      
    <span class="n">sps</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">sps</span><span class="p">();</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;sps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sps</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">dt</span><span class="p">();</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt</span>

    
    <span class="n">n</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">sps</span><span class="p">:]</span><span class="o">.</span><span class="n">len</span><span class="p">()</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">sps</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">n</span><span class="p">:</span> <span class="nb">input</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">sps</span><span class="p">:</span><span class="o">-</span><span class="n">n</span><span class="p">]</span>
    
    <span class="n">nslots</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span><span class="o">//</span><span class="n">sps</span><span class="o">//</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">nslots</span><span class="p">)</span>
    <span class="nb">input</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[:</span><span class="n">nslots</span><span class="o">*</span><span class="n">sps</span><span class="p">]</span>

    <span class="nb">input</span> <span class="o">=</span> <span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">signal</span> <span class="o">+</span> <span class="nb">input</span><span class="o">.</span><span class="n">noise</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="k">if</span> <span class="nb">input</span><span class="o">.</span><span class="n">noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">real</span>

    <span class="nb">input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="o">-</span><span class="n">sps</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># To focus the eye on the chart</span>
    <span class="n">y_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>

    <span class="c1"># resampled the signal to obtain a higher resolution in both axes</span>
    <span class="k">if</span> <span class="n">sps_resamp</span><span class="p">:</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">nslots</span><span class="o">*</span><span class="n">sps_resamp</span><span class="p">);</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nslots</span><span class="o">//</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">dt</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">sps_resamp</span><span class="p">));</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">input</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span><span class="o">//</span><span class="n">sps</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">dt</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">sps</span><span class="p">));</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>

    <span class="c1"># We obtain the centroid of the samples on the Y axis</span>
    <span class="n">vm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">)</span>

    <span class="c1"># we obtain the shortest interval of the upper half that contains 50% of the samples</span>
    <span class="n">top_int</span> <span class="o">=</span> <span class="n">shorth_int</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="nb">input</span><span class="o">&gt;</span><span class="n">vm</span><span class="p">])</span> 
    <span class="c1"># We obtain the LMS of level 1</span>
    <span class="n">state_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">top_int</span><span class="p">)</span>
    <span class="c1"># we obtain the shortest interval of the lower half that contains 50% of the samples</span>
    <span class="n">bot_int</span> <span class="o">=</span> <span class="n">shorth_int</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="nb">input</span><span class="o">&lt;</span><span class="n">vm</span><span class="p">])</span>
    <span class="c1"># We obtain the LMS of level 0</span>
    <span class="n">state_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bot_int</span><span class="p">)</span>

    <span class="c1"># We obtain the amplitude between the two levels 0 and 1</span>
    <span class="n">d01</span> <span class="o">=</span> <span class="n">state_1</span> <span class="o">-</span> <span class="n">state_0</span>

    <span class="c1"># We take 75% threshold level</span>
    <span class="n">v75</span> <span class="o">=</span> <span class="n">state_1</span> <span class="o">-</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">d01</span>

    <span class="c1"># We take 25% threshold level</span>
    <span class="n">v25</span> <span class="o">=</span> <span class="n">state_0</span> <span class="o">+</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">d01</span>

    <span class="n">t_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>

    <span class="k">try</span><span class="p">:</span> 
        <span class="c1"># The following vector will be used only to determine the crossing times</span>
        <span class="n">tt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[(</span><span class="nb">input</span><span class="o">&gt;</span><span class="n">v25</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="nb">input</span><span class="o">&lt;</span><span class="n">v75</span><span class="p">)]</span>

        <span class="c1"># We get the centroid of the time data</span>
        <span class="n">tm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sk</span><span class="o">.</span><span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">tt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">)</span>

        <span class="c1"># We obtain the left crossing time</span>
        <span class="n">t_left</span> <span class="o">=</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">t_set</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tt</span><span class="p">[</span><span class="n">tt</span><span class="o">&lt;</span><span class="n">tm</span><span class="p">]));</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_left&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_left</span>

        <span class="c1"># We obtain the crossing time from the right</span>
        <span class="n">t_right</span> <span class="o">=</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">t_set</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tt</span><span class="p">[</span><span class="n">tt</span><span class="o">&gt;</span><span class="n">tm</span><span class="p">]));</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_right</span>

        <span class="c1"># Determine the center of the eye</span>
        <span class="n">t_center</span> <span class="o">=</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">t_set</span><span class="p">,</span> <span class="p">(</span><span class="n">t_left</span> <span class="o">+</span> <span class="n">t_right</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_opt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_center</span>
    
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">t_left</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">;</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_left&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_left</span>
        <span class="n">t_right</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_right</span>
        <span class="n">t_center</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_opt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_center</span>
    
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">e</span>

    <span class="c1"># For 20% of the center of the eye diagram</span>
    <span class="n">t_dist</span> <span class="o">=</span> <span class="n">t_right</span> <span class="o">-</span> <span class="n">t_left</span><span class="p">;</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_dist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_dist</span>
    <span class="n">t_span0</span> <span class="o">=</span> <span class="n">t_center</span> <span class="o">-</span> <span class="mf">0.05</span><span class="o">*</span><span class="n">t_dist</span><span class="p">;</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_span0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_span0</span>
    <span class="n">t_span1</span> <span class="o">=</span> <span class="n">t_center</span> <span class="o">+</span> <span class="mf">0.05</span><span class="o">*</span><span class="n">t_dist</span><span class="p">;</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;t_span1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_span1</span>

    <span class="c1"># Within the 20% of the data in the center of the eye diagram, we separate into two clusters top and bottom</span>
    <span class="n">y_center</span> <span class="o">=</span> <span class="n">find_nearest</span><span class="p">(</span><span class="n">y_set</span><span class="p">,</span> <span class="p">(</span><span class="n">state_0</span> <span class="o">+</span> <span class="n">state_1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># We obtain the optimum time for down sampling</span>
    <span class="k">if</span> <span class="n">sps_resamp</span><span class="p">:</span>
        <span class="n">instant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t_center</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span> <span class="o">-</span> <span class="n">sps_resamp</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">instant</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">instant</span><span class="o">/</span><span class="n">sps_resamp</span><span class="o">*</span><span class="n">sps</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">instant</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">t_center</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span> <span class="o">-</span> <span class="n">sps</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">instant</span>

    <span class="c1"># We obtain the upper cluster</span>
    <span class="n">y_top</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[(</span><span class="nb">input</span> <span class="o">&gt;</span> <span class="n">y_center</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">t_span0</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_span1</span><span class="p">))];</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;y_top&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_top</span>

    <span class="c1"># We obtain the lower cluster</span>
    <span class="n">y_bot</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[(</span><span class="nb">input</span> <span class="o">&lt;</span> <span class="n">y_center</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">t_span0</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">t_span1</span><span class="p">))];</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;y_bot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_bot</span>

    <span class="c1"># For each cluster we calculated the means and standard deviations</span>
    <span class="n">mu1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_top</span><span class="p">);</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;mu1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu1</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">y_top</span><span class="p">);</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;s1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s1</span>
    <span class="n">mu0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_bot</span><span class="p">);</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;mu0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu0</span>
    <span class="n">s0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">y_bot</span><span class="p">);</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;s0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s0</span>

    <span class="c1"># We obtain the extinction ratio</span>
    <span class="n">er</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">mu1</span><span class="o">/</span><span class="n">mu0</span><span class="p">)</span> <span class="k">if</span> <span class="n">mu0</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">;</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;er&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">er</span>

    <span class="c1"># We obtain the eye opening</span>
    <span class="n">eye_h</span> <span class="o">=</span> <span class="n">mu1</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">s1</span> <span class="o">-</span> <span class="n">mu0</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">s0</span><span class="p">;</span> <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;eye_h&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eye_h</span>

    <span class="n">eye_dict</span><span class="p">[</span><span class="s1">&#39;execution_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">eye</span><span class="p">(</span><span class="o">**</span><span class="n">eye_dict</span><span class="p">)</span></div>



<div class="viewcode-block" id="SAMPLER">
<a class="viewcode-back" href="../../devices.html#opticomlib.devices.SAMPLER">[docs]</a>
<span class="k">def</span> <span class="nf">SAMPLER</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">electrical_signal</span><span class="p">,</span> <span class="n">_eye_</span><span class="p">:</span> <span class="n">eye</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;**Digital sampler**</span>

<span class="sd">    Receives an electrical signal and an eye object and performs the sampling of the signal</span>
<span class="sd">    at the optimal instant determined by the eye object.</span>

<span class="sd">    Args:</span>
<span class="sd">        input: The electrical signal to be sampled.</span>
<span class="sd">        _eye_: The eye object that contains the eye diagram information.</span>

<span class="sd">    Returns:</span>
<span class="sd">        electrical_signal: The sampled electrical signal at one sample per slot.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>
    <span class="n">output</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">_eye_</span><span class="o">.</span><span class="n">i</span><span class="p">::</span><span class="n">_eye_</span><span class="o">.</span><span class="n">sps</span><span class="p">]</span>

    <span class="n">output</span><span class="o">.</span><span class="n">execution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="FBG">
<a class="viewcode-back" href="../../devices.html#opticomlib.devices.FBG">[docs]</a>
<span class="k">def</span> <span class="nf">FBG</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> 
        <span class="n">neff</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.45</span><span class="p">,</span>
        <span class="n">v</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">landa_D</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fc</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">kL</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">L</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dneff</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">vdneff</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">apodization</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;uniform&#39;</span><span class="p">,</span> <span class="s1">&#39;rcos&#39;</span><span class="p">,</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="s1">&#39;parabolic&#39;</span><span class="p">],</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;uniform&#39;</span><span class="p">,</span>
        <span class="n">F</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">print_params</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">filtfilt</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">retH</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;**Fiber Bragg Grating**.</span>

<span class="sd">    This function numerically calculates the reflectivity (transfer function :math:`H(f)` in reflection) of the grating by</span>
<span class="sd">    solving the coupled-wave equations using `Runge-Kutta` method with help of ``signal.integrate.solve_ivp()`` function. See Notes_ </span>
<span class="sd">    section for more details.</span>
<span class="sd">    </span>
<span class="sd">    In order to design the grating, combination of the following parameters can be used:</span>
<span class="sd">    </span>
<span class="sd">    1. ``neff``, ``v``, ``fc``, (``dneff`` or ``vdneff``), (``N`` or ``kL`` or ``L``)</span>
<span class="sd">    2. ``neff``, ``v``, ``landaD``, (``dneff`` or ``vdneff``), (``N`` or ``kL`` or ``L``)</span>
<span class="sd">    3. ``neff``, ``v``, ``landaD``, ``kL``, (``N`` or ``L``)</span>

<span class="sd">    Bandwidth is governed essentially by three parameters:</span>

<span class="sd">    1. Bragg wavelength (:math:`\lambda_D`). Bandwidth is proportional to :math:`\lambda_D`.</span>
<span class="sd">    2. Product of visibility and effective index change (:math:`v\delta n_{eff}`). If :math:`v\delta n_{eff}` is small, the bandwidth is small.</span>
<span class="sd">    3. Length of the grating (:math:`L`). Bandwidth is inversely proportional to :math:`L`.</span>

<span class="sd">    On the other hand, chirp parameter :math:`F` can increase the bandwidth of the grating as well.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : :obj:`optical_signal`</span>
<span class="sd">        The input optical signal.</span>
<span class="sd">    neff : :obj:`float`, optional</span>
<span class="sd">        Effective refractive index of core fiber. Default is 1.45.</span>
<span class="sd">    v : :obj:`float`, optional</span>
<span class="sd">        Visibility of the grating. Default is 1.</span>
<span class="sd">    landa_D : :obj:`float`, optional</span>
<span class="sd">        Bragg wavelength (resonance wavelength). Default is None.</span>
<span class="sd">    fc : :obj:`float`, optional</span>
<span class="sd">        Center frequency of the grating. Default is None. </span>
<span class="sd">    kL : :obj:`float`, optional</span>
<span class="sd">        Product of the coupling coefficient and the length of the grating. Default is None.</span>
<span class="sd">    L : :obj:`float`, optional</span>
<span class="sd">        Length of the grating.  Default is None.</span>
<span class="sd">    N : :obj:`int`, optional</span>
<span class="sd">        Number of period along grating length. Default is None.</span>
<span class="sd">    dneff : :obj:`float`, optional</span>
<span class="sd">        Effective index change. Default is None.</span>
<span class="sd">    vdneff : :obj:`float`, optional </span>
<span class="sd">        Effective index change multiplied by visibility (case of approximation -&gt;0). Default is None.</span>
<span class="sd">    apodization : :obj:`str` or :obj:`callable`</span>
<span class="sd">        Apodization function. Can be an string with the name of the apodization function or a custom function. Default is ``&#39;uniform&#39;``.</span>
<span class="sd">        </span>
<span class="sd">        The following apodization functions are available:</span>

<span class="sd">        * ``&#39;uniform&#39;``: Uniform apodization, ``f(z) = 1``.</span>
<span class="sd">        * ``&#39;rcos&#39;``: Raised cosine apodization, ``f(z) = 1/2*(1 + np.cos(pi*z))``.</span>
<span class="sd">        * ``&#39;gaussian&#39;``: Gaussian apodization, ``f(z) = np.exp(-4*np.log(2)*(3*z)**2)``.</span>
<span class="sd">        * ``&#39;parabolic&#39;``: Parabolic apodization, ``f(z) = 1 - (2*z)**2``.</span>
<span class="sd">        </span>
<span class="sd">        If a custom function is used, it must be a function of the form ``f(z)`` </span>
<span class="sd">        where ``z`` is the position along the grating length normalized by ``L`` (i.e. ``z = z/L``),</span>
<span class="sd">        and the function must be defined in the range ``-0.5 &lt;= z &lt;= 0.5``.  </span>

<span class="sd">    F : :obj:`float`, optional</span>
<span class="sd">        Chirp parameter. Default is 0.</span>
<span class="sd">    filtfilt : :obj:`bool`, optional</span>
<span class="sd">        If True, group delay will be corrected in output signal. Default is True.</span>
<span class="sd">    retH : :obj:`bool`, optional</span>
<span class="sd">        If True, the function will return the reflectivity (H(w)) of the grating. Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output: :obj:`optical_signal`</span>
<span class="sd">        The reflected optical signal</span>
<span class="sd">    H: :obj:`np.ndarray`, optional</span>
<span class="sd">        Frequency response of grating fiber H(w), only returned if ``retH=True`` </span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If ``input`` is not an :obj:`optical_signal`.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the parameters are not correctly specified.</span>

<span class="sd">    Warns</span>
<span class="sd">    -----</span>
<span class="sd">    UserWarning</span>
<span class="sd">        If the apodization function is not recognized, a warning will be issued and the function will use uniform apodization.</span>
<span class="sd">    UserWarning</span>
<span class="sd">        If bandwith is too large, the function will issue a warning and will use a default bandwidth of `fs`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. _Notes:   </span>

<span class="sd">    Following coupled-wave theory, we assume a periodic, single-mode</span>
<span class="sd">    waveguide with an electromagnetic field which can be represented by</span>
<span class="sd">    two contradirectional coupled waves in the form [#first]_:</span>

<span class="sd">    .. math:: E(z) = A(z)e^{-j\beta_0 z} + B(z)e^{j\beta_0 z}</span>

<span class="sd">    where A and B are slowly varying amplitudes of mode traveling in :math:`+z` and math:`-z` directions, respectively</span>
<span class="sd">    These amplitudes are linked by the standard coupled-wave equations:</span>

<span class="sd">    .. math::</span>
<span class="sd">        R&#39; &amp;= j\hat{\sigma} R + j\kappa S \\</span>
<span class="sd">        S&#39; &amp;= -j\hat{\sigma} S - j\kappa R</span>

<span class="sd">    where :math:`R` and :math:`S` are :math:`R(z) = A(z)e^{j\delta z - \phi/2}` and :math:`S(z) = B(z)e^{-j\delta z + \phi/2}`. </span>
<span class="sd">    In these equations :math:`\kappa` is the AC coupling coefficient and :math:`\hat{\sigma}` is a general dc self-coupling coefficient defined as</span>
<span class="sd">    </span>
<span class="sd">    .. math:: \hat{\sigma} = \delta + \sigma - \frac{1}{2}\phi&#39;</span>

<span class="sd">    The detuning :math:`\delta`, which is independent of :math:`z` for all gratings, is defined to be</span>

<span class="sd">    .. math:: \delta = 2\pi n_{eff} \left( \frac{1}{\lambda} - \frac{1}{\lambda_{D}} \right)</span>

<span class="sd">    where :math:`\lambda_D = 2n_{eff}\Lambda` is the design wavelength for Bragg scattering by an infinitesimally weak grating :math:`(\delta n_{eff}\rightarrow 0)` with</span>
<span class="sd">    a period :math:`\Lambda`.</span>

<span class="sd">    For a single-mode Bragg reflection grating:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \sigma &amp;= \frac{2\pi}{\lambda}\delta n_{eff} \\</span>
<span class="sd">        \kappa &amp;= \frac{v}{2}\sigma = \frac{\pi}{\lambda}v\delta n_{eff}</span>
<span class="sd">        </span>
<span class="sd">    If the grating is uniform along :math:`z`, then :math:`\delta n_{eff}` is a constant and :math:`\phi&#39; = 0`, </span>
<span class="sd">    and thus :math:`\kappa`, :math:`\sigma`, and :math:`\hat{\sigma}` constants.</span>

<span class="sd">    For apodized gratings, :math:`\delta n_{eff}` is a function of :math:`z`, and therefore :math:`\kappa`, :math:`\sigma`, and :math:`\hat{\sigma}` are also functions of :math:`z`.</span>

<span class="sd">    If phase chirp is present, :math:`\phi` and :math:`\phi&#39;` are also a function of :math:`z`. This implementation considers only linear chirp, so:</span>

<span class="sd">    .. math:: \phi&#39;(z) = 2Fz/L^2</span>

<span class="sd">    where :math:`F` is a dimensionless &quot;chirp parameter&quot;, given by [#second]_:</span>
<span class="sd">    </span>
<span class="sd">    .. math:: F = \pi N \Delta \Lambda/\Lambda </span>

<span class="sd">    or </span>

<span class="sd">    .. math:: F = \pi N \Delta \lambda_D/\lambda_D = 2\pi n_{eff} \frac{\Delta \lambda_D}{\lambda_D^2}L</span>

<span class="sd">    where </span>
<span class="sd">    </span>
<span class="sd">    .. math:: \Delta \lambda_D = \lambda_D(z=-L/2) - \lambda_D(z=L/2)</span>

<span class="sd">    ODE resolution is performed using `scipy.integrate.solve_ivp` function:</span>

<span class="sd">    - Dimensionless variables are used: :math:`z = z/L`, :math:`\delta = \delta L`, :math:`\kappa = \kappa L`, :math:`\sigma = \sigma L`, :math:`\phi&#39; = \phi&#39; L`.</span>
<span class="sd">    - The integration is performed from :math:`z = 1/2` to :math:`z = -1/2`.</span>
<span class="sd">    - The initial conditions are :math:`R(1/2) = 1` and :math:`S(1/2) = 0`.</span>
<span class="sd">    - The output is the relation :math:`\rho = S(-1/2)/R(-1/2)`. </span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [#] Turan Erdogan, &quot;Fiber Grating Spectra,&quot; VOL. 15, NO. 8, AUGUST 1997. doi: https://doi.org/10.1109/50.618322</span>
<span class="sd">    .. [#] H. KOGELNIK, &quot;Filter Response of Nonuniform Almost-Periodic Structures&quot; Vol. 55, No. 1, January 1976. doi: https://doi.org/10.1002/j.1538-7305.1976.tb02062.x </span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    .. code-block:: python</span>
<span class="sd">        :linenos:</span>
<span class="sd">    </span>
<span class="sd">        from opticomlib import optical_signal, gv, pi, db, plt, np</span>
<span class="sd">        from opticomlib.devices import FBG</span>

<span class="sd">        gv(fs=100e9)</span>

<span class="sd">        x = optical_signal(np.ones(2**12))</span>
<span class="sd">        f = x.w(shift=True)/2/pi*1e-9</span>

<span class="sd">        for apo in [&#39;uniform&#39;, &#39;parabolic&#39;, &#39;rcos&#39;, &#39;gaussian&#39;]:</span>
<span class="sd">            _,H = FBG(x, fc=gv.f0, vdneff=1e-4, kL=16, apodization=apo, retH=True)</span>
<span class="sd">            plt.plot(f, db(np.abs(H)**2), lw=2, label=apo)</span>

<span class="sd">        plt.xlabel(&#39;Frequency (Hz)&#39;)</span>
<span class="sd">        plt.ylabel(&#39;Magnitude (dB)&#39;)</span>
<span class="sd">        plt.legend()</span>
<span class="sd">        plt.grid(alpha=0.3)</span>
<span class="sd">        plt.ylim(-100,)</span>
<span class="sd">        plt.xlim(-20, 20)</span>
<span class="sd">        plt.show()</span>

<span class="sd">    .. image:: /_images/FBG_example1.svg</span>
<span class="sd">        :align: center</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tic</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">optical_signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`input` must be of type (optical_signal).&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">fc</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dneff</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">L</span> <span class="ow">or</span> <span class="n">kL</span> <span class="ow">or</span> <span class="n">N</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If `fc` and `dneff` are specified, `L`, `kL` or `N` must be specified.&quot;</span><span class="p">)</span>
            
            <span class="n">landa_D</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">dneff</span><span class="o">/</span><span class="n">neff</span><span class="p">)</span><span class="o">*</span><span class="n">c</span><span class="o">/</span><span class="n">fc</span>
            <span class="n">vdneff</span> <span class="o">=</span> <span class="n">dneff</span><span class="o">*</span><span class="n">v</span>

            <span class="k">if</span> <span class="n">kL</span><span class="p">:</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">kL</span> <span class="o">/</span> <span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">dneff</span><span class="o">*</span><span class="n">v</span> <span class="o">/</span> <span class="n">landa_D</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">N</span><span class="p">:</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">landa_D</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">neff</span><span class="p">)</span> 
        
        <span class="k">elif</span> <span class="n">vdneff</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">L</span> <span class="ow">or</span> <span class="n">kL</span> <span class="ow">or</span> <span class="n">N</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If `fc` and `vdneff` are specified, `L`, `kL` or `N` must be specified.&quot;</span><span class="p">)</span>
            
            <span class="n">landa_D</span> <span class="o">=</span> <span class="n">c</span><span class="o">/</span><span class="n">fc</span>
            <span class="n">dneff</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">kL</span><span class="p">:</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">kL</span> <span class="o">/</span> <span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">vdneff</span> <span class="o">/</span> <span class="n">landa_D</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">N</span><span class="p">:</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">landa_D</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">neff</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If `fc` is specified, `dneff` or `vdneff` must be specified.&quot;</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="n">landa_D</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dneff</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">L</span> <span class="ow">or</span> <span class="n">kL</span> <span class="ow">or</span> <span class="n">N</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If `landa_D` and `dneff` are specified, `L`, `kL` or `N` must be specified.&quot;</span><span class="p">)</span>
            
            <span class="n">vdneff</span> <span class="o">=</span> <span class="n">dneff</span><span class="o">*</span><span class="n">v</span>

            <span class="k">if</span> <span class="n">kL</span><span class="p">:</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">kL</span> <span class="o">/</span> <span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">vdneff</span> <span class="o">/</span> <span class="n">landa_D</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">N</span><span class="p">:</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">landa_D</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">neff</span><span class="p">)</span> 

        <span class="k">elif</span> <span class="n">vdneff</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">L</span> <span class="ow">or</span> <span class="n">kL</span> <span class="ow">or</span> <span class="n">N</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If `landa_D` and `vdneff` are specified, `L`, `kL` or `N` must be specified.&quot;</span><span class="p">)</span>
            
            <span class="n">dneff</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">kL</span><span class="p">:</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">kL</span> <span class="o">/</span> <span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">vdneff</span> <span class="o">/</span> <span class="n">landa_D</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">N</span><span class="p">:</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">landa_D</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">neff</span><span class="p">)</span> 

        <span class="k">elif</span> <span class="n">kL</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">L</span> <span class="ow">or</span> <span class="n">N</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If `landa_D` and `kL` are specified, `L` or `N` must be specified.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">N</span><span class="p">:</span>
                <span class="n">L</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">landa_D</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">neff</span><span class="p">)</span>
            
            <span class="n">vdneff</span> <span class="o">=</span> <span class="n">kL</span><span class="o">*</span><span class="n">landa_D</span> <span class="o">/</span> <span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
            <span class="n">dneff</span> <span class="o">=</span> <span class="n">vdneff</span><span class="o">/</span><span class="n">v</span>

        <span class="k">else</span><span class="p">:</span> 
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If `landa_D` is specified, `dneff`, &#39;vdneff&#39; or `kL` must be specified.&quot;</span><span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either `fc` or `landa_D` must be specified.&quot;</span><span class="p">)</span>

 
    <span class="n">_D</span> <span class="o">=</span> <span class="n">landa_D</span>  <span class="c1"># Bragg wavelength</span>
    <span class="n"></span> <span class="o">=</span> <span class="n">_D</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">neff</span><span class="p">)</span>  <span class="c1"># period of the grating</span>
    
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">dneff</span><span class="o">/</span><span class="n">neff</span><span class="p">)</span><span class="o">*</span><span class="n">_D</span> <span class="c1"># center wavelength of the grating</span>
    <span class="n">fc</span> <span class="o">=</span> <span class="n">c</span><span class="o">/</span><span class="n">c</span> <span class="c1"># center frequency of the grating</span>
    
    <span class="n"></span> <span class="o">=</span>  <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">c</span> <span class="o">/</span> <span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="n">shift</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">gv</span><span class="o">.</span><span class="n">f0</span><span class="p">)</span> <span class="c1"># wavelength vector, centered at global variable f0</span>
    <span class="n"></span> <span class="o">=</span> <span class="n"></span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n"></span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># wavelength resolution</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">L</span><span class="o">/</span><span class="n"></span><span class="p">)</span> <span class="c1"># number of periods of the grating</span>

    <span class="n">kL</span> <span class="o">=</span> <span class="n">pi</span><span class="o">/</span><span class="n">_D</span><span class="o">*</span><span class="n">vdneff</span><span class="o">*</span><span class="n">L</span>

    <span class="n"></span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">neff</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n"></span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">_D</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">dneff</span> <span class="o">/</span> <span class="n"></span> <span class="o">*</span> <span class="n">L</span>   <span class="c1"># self-coupling coefficient DC</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">pi</span><span class="o">*</span><span class="n">vdneff</span> <span class="o">/</span> <span class="n"></span> <span class="o">*</span> <span class="n">L</span> <span class="c1"># self-coupling coefficient AC</span>
    
    <span class="k">def</span> <span class="nf">ode_system</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n"></span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">apo_func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="c1"># ODE function, normalized to L (z/L, L, L, kL)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span>

        <span class="k">if</span> <span class="n">apo_func</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">apo_func</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">p</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">p</span> 

        <span class="n">s_</span> <span class="o">=</span> <span class="n"></span> <span class="o">+</span> <span class="n">s</span> <span class="o">-</span> <span class="n">F</span><span class="o">*</span><span class="n">z</span>

        <span class="n">dRdz</span> <span class="o">=</span>  <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">s_</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="n">S</span><span class="p">)</span>
        <span class="n">dSdz</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">s_</span> <span class="o">*</span> <span class="n">S</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="n">R</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">dRdz</span><span class="p">,</span> <span class="n">dSdz</span><span class="p">]</span>
        
    <span class="n"></span> <span class="o">=</span> <span class="n"></span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="c1"># initial conditions</span>
    <span class="n">S0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">R0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">R0</span><span class="p">,</span> <span class="n">S0</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">apodization</span> <span class="o">==</span> <span class="s1">&#39;rcos&#39;</span><span class="p">:</span>
        <span class="n">apo_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">rcos</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">apodization</span> <span class="o">==</span> <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span>
        <span class="n">apo_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">apodization</span> <span class="o">==</span> <span class="s1">&#39;parabolic&#39;</span><span class="p">:</span>
        <span class="n">apo_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">elif</span> <span class="n">apodization</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
        <span class="n">apo_func</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">apodization</span><span class="p">):</span> <span class="c1"># custom apodization function</span>
        <span class="n">apo_func</span> <span class="o">=</span> <span class="n">apodization</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">apodization</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Apodization function not recognized. Using uniform apodization.&quot;</span><span class="p">)</span>
        <span class="n">apo_func</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Apodization must be a string or a function.&quot;</span><span class="p">)</span>

    <span class="n">sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="n">ode_system</span><span class="p">,</span> 
                    <span class="n">t_span</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">],</span> 
                    <span class="n">y0</span> <span class="o">=</span> <span class="n">y0</span><span class="p">,</span> 
                    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;RK45&#39;</span><span class="p">,</span> 
                    <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n"></span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">apo_func</span><span class="p">),</span> 
                    <span class="n">vectorized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="n">y</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">S</span><span class="o">/</span><span class="n">R</span>   

    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="c1"># reflectivity of the grating</span>

    <span class="n">ic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n"></span> <span class="o">-</span> <span class="n">c</span><span class="o">/</span><span class="n">fc</span><span class="p">))</span>

    <span class="n">peaks</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">H_max</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span>

    
    <span class="k">if</span> <span class="p">(</span><span class="n">y</span><span class="o">&gt;</span><span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Bandwidth of the grating is too large for current sampling rate (`fs`). Consider increasing `fs`.&quot;</span><span class="p">)</span>
        <span class="n">bandwith_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39; - f = &gt;</span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span><span class="s2">&quot;Hz&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1"> ( = &gt;</span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">fs</span><span class="o">*</span><span class="n">c</span><span class="o">/</span><span class="n">fc</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="s2">&quot;m&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span>
    <span class="c1"># elif (y&lt;0.01).all():</span>
    <span class="c1">#     raise ValueError(&quot;Maximum reflectivity is less than 1%.&quot;) </span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">peak_widths</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">peaks</span><span class="p">)</span>

        <span class="n">BW_</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="n"></span>
        <span class="n">BW_f</span> <span class="o">=</span> <span class="n">fc</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">BW_</span><span class="o">/</span><span class="n">c</span>

        <span class="n">bandwith_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39; - f = </span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">BW_f</span><span class="p">,</span><span class="s2">&quot;Hz&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1"> ( = </span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">BW_</span><span class="p">,</span><span class="s2">&quot;m&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No peaks found in the reflectivity of the grating.&quot;</span><span class="p">)</span>
        <span class="n">bandwith_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39; - f = -- GHz ( = -- nm)&#39;</span>

    <span class="n">D</span> <span class="o">=</span> <span class="n">dispersion</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">gv</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">fc</span><span class="p">)[</span><span class="n">ic</span><span class="p">]</span> <span class="c1"># dispersion in ps/nm</span>

    <span class="c1">## Print parameters of the grating</span>
    <span class="k">if</span> <span class="n">print_params</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">*** Fiber Bragg Grating Features ***&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; -  = </span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n"></span><span class="p">,</span><span class="s2">&quot;m&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; - N = </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; - L = </span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="s2">&quot;m&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; - c = </span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">c</span><span class="o">/</span><span class="n">fc</span><span class="p">,</span><span class="s2">&quot;m&quot;</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">bandwith_str</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; - o = </span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; - loss = </span><span class="si">{</span><span class="o">-</span><span class="n">db</span><span class="p">(</span><span class="n">H_max</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1"> dB&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; - vneff = </span><span class="si">{</span><span class="n">vdneff</span><span class="si">:</span><span class="s1">.1e</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; - kL = </span><span class="si">{</span><span class="n">kL</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; - D(c) = </span><span class="si">{</span><span class="n">D</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1"> ps/nm&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">F</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; - F = </span><span class="si">{</span><span class="n">F</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; -  = </span><span class="si">{</span><span class="n">si</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n"></span><span class="o">*</span><span class="n">F</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">N</span><span class="p">)),</span><span class="s2">&quot;m&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;************************************</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">filtfilt</span><span class="p">:</span> <span class="c1">## correct H(w)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="nb">input</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="n">shift</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">tau_g</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">gv</span><span class="o">.</span><span class="n">fs</span><span class="p">)[</span><span class="n">ic</span><span class="p">]</span><span class="o">*</span><span class="mf">1e-12</span><span class="p">)</span> <span class="c1"># corrected H(w)</span>

    <span class="c1">## apply to input optical signal</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">ifft</span><span class="p">(</span><span class="n">fft</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">)</span><span class="o">*</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">H</span><span class="p">))</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">optical_signal</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
    <span class="n">output</span><span class="o">.</span><span class="n">execution_time</span> <span class="o">=</span> <span class="n">toc</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">retH</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">H</span>
    <span class="k">return</span> <span class="n">output</span></div>









<span class="c1">### algunas funciones de prueba</span>
<span class="k">def</span> <span class="nf">animated_fiber_propagation</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> <span class="n">M</span> <span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">length_</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">alpha_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">beta_2_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">beta_3_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">gamma_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">phi_max</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">matplotlib.animation</span> <span class="kn">import</span> <span class="n">FuncAnimation</span>

    <span class="c1"># cambio las unidades</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">length_</span> <span class="o">*</span> <span class="mf">1e3</span> 
    <span class="n">alpha</span>  <span class="o">=</span> <span class="n">alpha_</span> <span class="o">*</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mf">4.343</span><span class="o">*</span><span class="mf">1e3</span><span class="p">)</span>
    <span class="n">beta_2</span> <span class="o">=</span> <span class="n">beta_2_</span> <span class="o">*</span> <span class="mf">1e-12</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">1e3</span>
    <span class="n">beta_3</span> <span class="o">=</span> <span class="n">beta_3_</span> <span class="o">*</span> <span class="mf">1e-12</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mf">1e3</span>
    <span class="n">gamma</span>  <span class="o">=</span> <span class="n">gamma_</span> <span class="o">*</span> <span class="mi">1</span><span class="o">/</span><span class="mf">1e3</span>

    <span class="n">w</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">w</span><span class="p">()</span>
    <span class="n">D_op</span> <span class="o">=</span> <span class="o">-</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">beta_2</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">6</span> <span class="o">*</span> <span class="n">beta_3</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">3</span>

    <span class="n">A</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="k">if</span> <span class="p">(</span><span class="n">beta_2</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">beta_3</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">gamma</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="n">phi_max</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="n">x_length</span> <span class="o">=</span> <span class="n">h</span>
    <span class="n">A_z</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">]</span>
    <span class="n">hs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">exp_NL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D_op</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span> <span class="n">exp_L</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">A_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">hs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">phi_max</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">if</span> <span class="n">gamma</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">length</span> 

        <span class="k">if</span> <span class="n">x_length</span> <span class="o">+</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">x_length</span> <span class="o">+=</span> <span class="n">h</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">x_length</span>
    
    <span class="k">if</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">exp_NL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D_op</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span> <span class="n">exp_L</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">A_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">hs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">t</span><span class="p">()</span><span class="o">*</span><span class="n">gv</span><span class="o">.</span><span class="n">slot_rate</span>

    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

    <span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
    <span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Fiber: $\alpha = </span><span class="si">{:.2f}</span><span class="s1">$ dB/km, $\beta_2 = </span><span class="si">{}</span><span class="s1">$ ps^2/km, $\gamma = </span><span class="si">{}</span><span class="s1">$ (Wkm)^-1&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">alpha_</span><span class="p">,</span> <span class="n">beta_2_</span><span class="p">,</span> <span class="n">gamma_</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$t/T_</span><span class="si">{slot}</span><span class="s1">$&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;|A(z,t)|&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">*</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1.05</span><span class="p">))</span>

    <span class="n">time_text</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span><span class="mf">0.9</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
        <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">([],[])</span>
        <span class="n">time_text</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s1">&#39;z = 0.0 Km&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[::</span><span class="n">M</span><span class="o">*</span><span class="n">gv</span><span class="o">.</span><span class="n">sps</span><span class="p">]:</span>
           <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[::</span><span class="n">gv</span><span class="o">.</span><span class="n">sps</span><span class="p">]:</span>
           <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">line</span><span class="p">,</span> <span class="n">time_text</span><span class="p">]</span> 

    <span class="k">def</span> <span class="nf">animate</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">line</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">time_text</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s1">&#39;z = </span><span class="si">{:.2f}</span><span class="s1"> Km&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">hs</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mf">1e3</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">line</span><span class="p">,</span> <span class="n">time_text</span><span class="p">]</span> 

    <span class="n">anim</span> <span class="o">=</span> <span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">animate</span><span class="p">,</span> <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">A_z</span><span class="p">),</span> <span class="n">interval</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">animated_fiber_propagation_with_psd</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="n">optical_signal</span><span class="p">,</span> <span class="n">M</span> <span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">length_</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">alpha_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">beta_2_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">beta_3_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">gamma_</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">phi_max</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">matplotlib.animation</span> <span class="kn">import</span> <span class="n">FuncAnimation</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">n</span><span class="o">*</span><span class="n">M</span><span class="o">*</span><span class="nb">input</span><span class="o">.</span><span class="n">sps</span><span class="p">()</span> 
    
    <span class="n">length</span> <span class="o">=</span> <span class="n">length_</span>
    <span class="n">alpha</span>  <span class="o">=</span> <span class="n">alpha_</span><span class="o">/</span><span class="mf">4.343</span>
    <span class="n">beta_2</span> <span class="o">=</span> <span class="n">beta_2_</span>
    <span class="n">beta_3</span> <span class="o">=</span> <span class="n">beta_3_</span>
    <span class="n">gamma</span>  <span class="o">=</span> <span class="n">gamma_</span>

    <span class="n">w</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">w</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e-12</span> <span class="c1"># rad/ps</span>
    <span class="n">D_op</span> <span class="o">=</span> <span class="o">-</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">beta_2</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">6</span> <span class="o">*</span> <span class="n">beta_3</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">3</span>

    <span class="n">A</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">signal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="k">if</span> <span class="p">(</span><span class="n">beta_2</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">beta_3</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">gamma</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="n">phi_max</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="n">x_length</span> <span class="o">=</span> <span class="n">h</span>
    <span class="n">A_z</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">]</span>
    <span class="n">A_z_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">fft</span><span class="p">(</span><span class="n">A</span><span class="p">)]</span>
    <span class="n">hs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">exp_NL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D_op</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span> <span class="n">exp_L</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">A_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">x_length</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">A_z_w</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fft</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">x_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">hs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">phi_max</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">if</span> <span class="n">gamma</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">length</span> 

        <span class="k">if</span> <span class="n">x_length</span> <span class="o">+</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="n">x_length</span> <span class="o">+=</span> <span class="n">h</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">x_length</span>
    
    <span class="k">if</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">exp_NL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">D_op</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">ifft</span><span class="p">(</span> <span class="n">exp_L</span> <span class="o">*</span> <span class="n">fft</span><span class="p">(</span> <span class="n">exp_NL</span> <span class="o">*</span> <span class="n">A</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">A_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">length</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">A_z_w</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fft</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">length</span><span class="o">/</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">hs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">t</span><span class="p">()</span><span class="o">*</span><span class="n">gv</span><span class="o">.</span><span class="n">slot_rate</span>

    <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span><span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>

    <span class="n">line1</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">[</span><span class="mi">0</span><span class="p">])[:</span><span class="n">n</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
    <span class="n">line1</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Fiber: $\alpha = </span><span class="si">{:.2f}</span><span class="s1">$ dB/km, $\beta_2 = </span><span class="si">{}</span><span class="s1">$ ps^2/km, $\gamma = </span><span class="si">{}</span><span class="s1">$ (Wkm)^-1&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">alpha_</span><span class="p">,</span> <span class="n">beta_2_</span><span class="p">,</span> <span class="n">gamma_</span><span class="p">))</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;t/T&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;|A(z,t)|&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">[:</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>

    <span class="n">z_text</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span><span class="mf">0.9</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">transform</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">transAxes</span><span class="p">)</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="mf">1e3</span> <span class="c1"># GHz</span>

    <span class="n">line2</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z_w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">(),</span> <span class="s1">&#39;--g&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">line2</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;f [GHz]&#39;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$|A(z,w)|^2$&#39;</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="o">-</span><span class="n">f</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftshift</span><span class="p">(</span><span class="n">A_z_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.001</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z_w</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="p">))</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z_w</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="mf">1.05</span><span class="o">/</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()))</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">init</span><span class="p">():</span>
        <span class="n">line1</span><span class="o">.</span><span class="n">set_data</span><span class="p">([],[])</span>
        <span class="n">z_text</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s1">&#39;z = 0.0 Km&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[:</span><span class="n">n</span><span class="p">:</span><span class="n">M</span><span class="o">*</span><span class="n">gv</span><span class="o">.</span><span class="n">sps</span><span class="p">]:</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">[:</span><span class="n">n</span><span class="p">:</span><span class="n">gv</span><span class="o">.</span><span class="n">sps</span><span class="p">]:</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">line1</span><span class="p">,</span> <span class="n">z_text</span><span class="p">]</span> 

    <span class="k">def</span> <span class="nf">animate</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">line1</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">y</span><span class="p">[:</span><span class="n">n</span><span class="p">])</span>
        <span class="n">z_text</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s1">&#39;z = </span><span class="si">{:.2f}</span><span class="s1"> Km&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">hs</span><span class="p">)[</span><span class="n">i</span><span class="p">]))</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A_z_w</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="nb">input</span><span class="o">.</span><span class="n">len</span><span class="p">()</span>
        <span class="n">line2</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">line1</span><span class="p">,</span> <span class="n">line2</span><span class="p">,</span> <span class="n">z_text</span><span class="p">]</span> 

    <span class="n">anim</span> <span class="o">=</span> <span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">animate</span><span class="p">,</span> <span class="n">init_func</span><span class="o">=</span><span class="n">init</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">A_z</span><span class="p">),</span> <span class="n">interval</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">blit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">pass</span>



</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Ing. Armando P. Romeu.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>